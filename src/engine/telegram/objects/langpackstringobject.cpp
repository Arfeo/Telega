// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "langpackstringobject.h"

LangPackStringObject::LangPackStringObject(const LangPackString &core, QObject *parent) :
    TelegramTypeQObject(parent),
    m_core(core)
{
}

LangPackStringObject::LangPackStringObject(QObject *parent) :
    TelegramTypeQObject(parent),
    m_core()
{
}

LangPackStringObject::~LangPackStringObject() {
}

void LangPackStringObject::setFewValue(const QString &fewValue) {
    if(m_core.fewValue() == fewValue) return;
    m_core.setFewValue(fewValue);
    Q_EMIT fewValueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::fewValue() const {
    return m_core.fewValue();
}

void LangPackStringObject::setFlags(qint32 flags) {
    if(m_core.flags() == flags) return;
    m_core.setFlags(flags);
    Q_EMIT flagsChanged();
    Q_EMIT coreChanged();
}

qint32 LangPackStringObject::flags() const {
    return m_core.flags();
}

void LangPackStringObject::setKey(const QString &key) {
    if(m_core.key() == key) return;
    m_core.setKey(key);
    Q_EMIT keyChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::key() const {
    return m_core.key();
}

void LangPackStringObject::setManyValue(const QString &manyValue) {
    if(m_core.manyValue() == manyValue) return;
    m_core.setManyValue(manyValue);
    Q_EMIT manyValueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::manyValue() const {
    return m_core.manyValue();
}

void LangPackStringObject::setOneValue(const QString &oneValue) {
    if(m_core.oneValue() == oneValue) return;
    m_core.setOneValue(oneValue);
    Q_EMIT oneValueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::oneValue() const {
    return m_core.oneValue();
}

void LangPackStringObject::setOtherValue(const QString &otherValue) {
    if(m_core.otherValue() == otherValue) return;
    m_core.setOtherValue(otherValue);
    Q_EMIT otherValueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::otherValue() const {
    return m_core.otherValue();
}

void LangPackStringObject::setTwoValue(const QString &twoValue) {
    if(m_core.twoValue() == twoValue) return;
    m_core.setTwoValue(twoValue);
    Q_EMIT twoValueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::twoValue() const {
    return m_core.twoValue();
}

void LangPackStringObject::setValue(const QString &value) {
    if(m_core.value() == value) return;
    m_core.setValue(value);
    Q_EMIT valueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::value() const {
    return m_core.value();
}

void LangPackStringObject::setZeroValue(const QString &zeroValue) {
    if(m_core.zeroValue() == zeroValue) return;
    m_core.setZeroValue(zeroValue);
    Q_EMIT zeroValueChanged();
    Q_EMIT coreChanged();
}

QString LangPackStringObject::zeroValue() const {
    return m_core.zeroValue();
}

LangPackStringObject &LangPackStringObject::operator =(const LangPackString &b) {
    if(m_core == b) return *this;
    m_core = b;

    Q_EMIT fewValueChanged();
    Q_EMIT flagsChanged();
    Q_EMIT keyChanged();
    Q_EMIT manyValueChanged();
    Q_EMIT oneValueChanged();
    Q_EMIT otherValueChanged();
    Q_EMIT twoValueChanged();
    Q_EMIT valueChanged();
    Q_EMIT zeroValueChanged();
    Q_EMIT coreChanged();
    return *this;
}

bool LangPackStringObject::operator ==(const LangPackString &b) const {
    return m_core == b;
}

void LangPackStringObject::setClassType(quint32 classType) {
    LangPackString::LangPackStringClassType result;
    switch(classType) {
    case TypeLangPackString:
        result = LangPackString::typeLangPackString;
        break;
    case TypeLangPackStringPluralized:
        result = LangPackString::typeLangPackStringPluralized;
        break;
    case TypeLangPackStringDeleted:
        result = LangPackString::typeLangPackStringDeleted;
        break;
    default:
        result = LangPackString::typeLangPackString;
        break;
    }

    if(m_core.classType() == result) return;
    m_core.setClassType(result);
    Q_EMIT classTypeChanged();
    Q_EMIT coreChanged();
}

quint32 LangPackStringObject::classType() const {
    int result;
    switch(static_cast<qint64>(m_core.classType())) {
    case LangPackString::typeLangPackString:
        result = TypeLangPackString;
        break;
    case LangPackString::typeLangPackStringPluralized:
        result = TypeLangPackStringPluralized;
        break;
    case LangPackString::typeLangPackStringDeleted:
        result = TypeLangPackStringDeleted;
        break;
    default:
        result = TypeLangPackString;
        break;
    }

    return result;
}

void LangPackStringObject::setCore(const LangPackString &core) {
    operator =(core);
}

LangPackString LangPackStringObject::core() const {
    return m_core;
}

