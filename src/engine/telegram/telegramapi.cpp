// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "telegramapi.h"
#include "telegram/types/types.h"
#include "telegram/functions/functions.h"
#include "telegram/coretypes.h"
#include "util/tlvalues.h"
#include "core/dcprovider.h"
#include "secret/encrypter.h"

#define DEBUG_FUNCTION \
    qCDebug(TG_CORE_API) << __LINE__ << __FUNCTION__;

#define CHECK_SESSION(SESSION) \
    if(!SESSION) \
        return 0;

#define INIT_MAIN_CONNECTION(SESSION)

using namespace Tg;

TelegramApi::TelegramApi(Session *session, Settings *settings, CryptoUtils *crypto, QObject *parent) :
    AbstractApi(session, settings, crypto, parent),
    mSettings(settings),
    mCrypto(crypto)
{
    accountRegisterDeviceMethods.onAnswer = &TelegramApi::onAccountRegisterDeviceAnswer;
    accountRegisterDeviceMethods.onError = &TelegramApi::onAccountRegisterDeviceError;
    accountUnregisterDeviceMethods.onAnswer = &TelegramApi::onAccountUnregisterDeviceAnswer;
    accountUnregisterDeviceMethods.onError = &TelegramApi::onAccountUnregisterDeviceError;
    accountUpdateNotifySettingsMethods.onAnswer = &TelegramApi::onAccountUpdateNotifySettingsAnswer;
    accountUpdateNotifySettingsMethods.onError = &TelegramApi::onAccountUpdateNotifySettingsError;
    accountGetNotifySettingsMethods.onAnswer = &TelegramApi::onAccountGetNotifySettingsAnswer;
    accountGetNotifySettingsMethods.onError = &TelegramApi::onAccountGetNotifySettingsError;
    accountResetNotifySettingsMethods.onAnswer = &TelegramApi::onAccountResetNotifySettingsAnswer;
    accountResetNotifySettingsMethods.onError = &TelegramApi::onAccountResetNotifySettingsError;
    accountUpdateProfileMethods.onAnswer = &TelegramApi::onAccountUpdateProfileAnswer;
    accountUpdateProfileMethods.onError = &TelegramApi::onAccountUpdateProfileError;
    accountUpdateStatusMethods.onAnswer = &TelegramApi::onAccountUpdateStatusAnswer;
    accountUpdateStatusMethods.onError = &TelegramApi::onAccountUpdateStatusError;
    accountGetWallPapersMethods.onAnswer = &TelegramApi::onAccountGetWallPapersAnswer;
    accountGetWallPapersMethods.onError = &TelegramApi::onAccountGetWallPapersError;
    accountReportPeerMethods.onAnswer = &TelegramApi::onAccountReportPeerAnswer;
    accountReportPeerMethods.onError = &TelegramApi::onAccountReportPeerError;
    accountCheckUsernameMethods.onAnswer = &TelegramApi::onAccountCheckUsernameAnswer;
    accountCheckUsernameMethods.onError = &TelegramApi::onAccountCheckUsernameError;
    accountUpdateUsernameMethods.onAnswer = &TelegramApi::onAccountUpdateUsernameAnswer;
    accountUpdateUsernameMethods.onError = &TelegramApi::onAccountUpdateUsernameError;
    accountGetPrivacyMethods.onAnswer = &TelegramApi::onAccountGetPrivacyAnswer;
    accountGetPrivacyMethods.onError = &TelegramApi::onAccountGetPrivacyError;
    accountSetPrivacyMethods.onAnswer = &TelegramApi::onAccountSetPrivacyAnswer;
    accountSetPrivacyMethods.onError = &TelegramApi::onAccountSetPrivacyError;
    accountDeleteAccountMethods.onAnswer = &TelegramApi::onAccountDeleteAccountAnswer;
    accountDeleteAccountMethods.onError = &TelegramApi::onAccountDeleteAccountError;
    accountGetAccountTTLMethods.onAnswer = &TelegramApi::onAccountGetAccountTTLAnswer;
    accountGetAccountTTLMethods.onError = &TelegramApi::onAccountGetAccountTTLError;
    accountSetAccountTTLMethods.onAnswer = &TelegramApi::onAccountSetAccountTTLAnswer;
    accountSetAccountTTLMethods.onError = &TelegramApi::onAccountSetAccountTTLError;
    accountSendChangePhoneCodeMethods.onAnswer = &TelegramApi::onAccountSendChangePhoneCodeAnswer;
    accountSendChangePhoneCodeMethods.onError = &TelegramApi::onAccountSendChangePhoneCodeError;
    accountChangePhoneMethods.onAnswer = &TelegramApi::onAccountChangePhoneAnswer;
    accountChangePhoneMethods.onError = &TelegramApi::onAccountChangePhoneError;
    accountUpdateDeviceLockedMethods.onAnswer = &TelegramApi::onAccountUpdateDeviceLockedAnswer;
    accountUpdateDeviceLockedMethods.onError = &TelegramApi::onAccountUpdateDeviceLockedError;
    accountGetAuthorizationsMethods.onAnswer = &TelegramApi::onAccountGetAuthorizationsAnswer;
    accountGetAuthorizationsMethods.onError = &TelegramApi::onAccountGetAuthorizationsError;
    accountResetAuthorizationMethods.onAnswer = &TelegramApi::onAccountResetAuthorizationAnswer;
    accountResetAuthorizationMethods.onError = &TelegramApi::onAccountResetAuthorizationError;
    accountGetPasswordMethods.onAnswer = &TelegramApi::onAccountGetPasswordAnswer;
    accountGetPasswordMethods.onError = &TelegramApi::onAccountGetPasswordError;
    accountGetPasswordSettingsMethods.onAnswer = &TelegramApi::onAccountGetPasswordSettingsAnswer;
    accountGetPasswordSettingsMethods.onError = &TelegramApi::onAccountGetPasswordSettingsError;
    accountUpdatePasswordSettingsMethods.onAnswer = &TelegramApi::onAccountUpdatePasswordSettingsAnswer;
    accountUpdatePasswordSettingsMethods.onError = &TelegramApi::onAccountUpdatePasswordSettingsError;
    accountSendConfirmPhoneCodeMethods.onAnswer = &TelegramApi::onAccountSendConfirmPhoneCodeAnswer;
    accountSendConfirmPhoneCodeMethods.onError = &TelegramApi::onAccountSendConfirmPhoneCodeError;
    accountConfirmPhoneMethods.onAnswer = &TelegramApi::onAccountConfirmPhoneAnswer;
    accountConfirmPhoneMethods.onError = &TelegramApi::onAccountConfirmPhoneError;
    accountGetTmpPasswordMethods.onAnswer = &TelegramApi::onAccountGetTmpPasswordAnswer;
    accountGetTmpPasswordMethods.onError = &TelegramApi::onAccountGetTmpPasswordError;

    authCheckPhoneMethods.onAnswer = &TelegramApi::onAuthCheckPhoneAnswer;
    authCheckPhoneMethods.onError = &TelegramApi::onAuthCheckPhoneError;
    authSendCodeMethods.onAnswer = &TelegramApi::onAuthSendCodeAnswer;
    authSendCodeMethods.onError = &TelegramApi::onAuthSendCodeError;
    authSignUpMethods.onAnswer = &TelegramApi::onAuthSignUpAnswer;
    authSignUpMethods.onError = &TelegramApi::onAuthSignUpError;
    authSignInMethods.onAnswer = &TelegramApi::onAuthSignInAnswer;
    authSignInMethods.onError = &TelegramApi::onAuthSignInError;
    authLogOutMethods.onAnswer = &TelegramApi::onAuthLogOutAnswer;
    authLogOutMethods.onError = &TelegramApi::onAuthLogOutError;
    authResetAuthorizationsMethods.onAnswer = &TelegramApi::onAuthResetAuthorizationsAnswer;
    authResetAuthorizationsMethods.onError = &TelegramApi::onAuthResetAuthorizationsError;
    authSendInvitesMethods.onAnswer = &TelegramApi::onAuthSendInvitesAnswer;
    authSendInvitesMethods.onError = &TelegramApi::onAuthSendInvitesError;
    authExportAuthorizationMethods.onAnswer = &TelegramApi::onAuthExportAuthorizationAnswer;
    authExportAuthorizationMethods.onError = &TelegramApi::onAuthExportAuthorizationError;
    authImportAuthorizationMethods.onAnswer = &TelegramApi::onAuthImportAuthorizationAnswer;
    authImportAuthorizationMethods.onError = &TelegramApi::onAuthImportAuthorizationError;
    authBindTempAuthKeyMethods.onAnswer = &TelegramApi::onAuthBindTempAuthKeyAnswer;
    authBindTempAuthKeyMethods.onError = &TelegramApi::onAuthBindTempAuthKeyError;
    authImportBotAuthorizationMethods.onAnswer = &TelegramApi::onAuthImportBotAuthorizationAnswer;
    authImportBotAuthorizationMethods.onError = &TelegramApi::onAuthImportBotAuthorizationError;
    authCheckPasswordMethods.onAnswer = &TelegramApi::onAuthCheckPasswordAnswer;
    authCheckPasswordMethods.onError = &TelegramApi::onAuthCheckPasswordError;
    authRequestPasswordRecoveryMethods.onAnswer = &TelegramApi::onAuthRequestPasswordRecoveryAnswer;
    authRequestPasswordRecoveryMethods.onError = &TelegramApi::onAuthRequestPasswordRecoveryError;
    authRecoverPasswordMethods.onAnswer = &TelegramApi::onAuthRecoverPasswordAnswer;
    authRecoverPasswordMethods.onError = &TelegramApi::onAuthRecoverPasswordError;
    authResendCodeMethods.onAnswer = &TelegramApi::onAuthResendCodeAnswer;
    authResendCodeMethods.onError = &TelegramApi::onAuthResendCodeError;
    authCancelCodeMethods.onAnswer = &TelegramApi::onAuthCancelCodeAnswer;
    authCancelCodeMethods.onError = &TelegramApi::onAuthCancelCodeError;
    authDropTempAuthKeysMethods.onAnswer = &TelegramApi::onAuthDropTempAuthKeysAnswer;
    authDropTempAuthKeysMethods.onError = &TelegramApi::onAuthDropTempAuthKeysError;

    botsSendCustomRequestMethods.onAnswer = &TelegramApi::onBotsSendCustomRequestAnswer;
    botsSendCustomRequestMethods.onError = &TelegramApi::onBotsSendCustomRequestError;
    botsAnswerWebhookJSONQueryMethods.onAnswer = &TelegramApi::onBotsAnswerWebhookJSONQueryAnswer;
    botsAnswerWebhookJSONQueryMethods.onError = &TelegramApi::onBotsAnswerWebhookJSONQueryError;

    channelsReadHistoryMethods.onAnswer = &TelegramApi::onChannelsReadHistoryAnswer;
    channelsReadHistoryMethods.onError = &TelegramApi::onChannelsReadHistoryError;
    channelsDeleteMessagesMethods.onAnswer = &TelegramApi::onChannelsDeleteMessagesAnswer;
    channelsDeleteMessagesMethods.onError = &TelegramApi::onChannelsDeleteMessagesError;
    channelsDeleteUserHistoryMethods.onAnswer = &TelegramApi::onChannelsDeleteUserHistoryAnswer;
    channelsDeleteUserHistoryMethods.onError = &TelegramApi::onChannelsDeleteUserHistoryError;
    channelsReportSpamMethods.onAnswer = &TelegramApi::onChannelsReportSpamAnswer;
    channelsReportSpamMethods.onError = &TelegramApi::onChannelsReportSpamError;
    channelsGetMessagesMethods.onAnswer = &TelegramApi::onChannelsGetMessagesAnswer;
    channelsGetMessagesMethods.onError = &TelegramApi::onChannelsGetMessagesError;
    channelsGetParticipantsMethods.onAnswer = &TelegramApi::onChannelsGetParticipantsAnswer;
    channelsGetParticipantsMethods.onError = &TelegramApi::onChannelsGetParticipantsError;
    channelsGetParticipantMethods.onAnswer = &TelegramApi::onChannelsGetParticipantAnswer;
    channelsGetParticipantMethods.onError = &TelegramApi::onChannelsGetParticipantError;
    channelsGetChannelsMethods.onAnswer = &TelegramApi::onChannelsGetChannelsAnswer;
    channelsGetChannelsMethods.onError = &TelegramApi::onChannelsGetChannelsError;
    channelsGetFullChannelMethods.onAnswer = &TelegramApi::onChannelsGetFullChannelAnswer;
    channelsGetFullChannelMethods.onError = &TelegramApi::onChannelsGetFullChannelError;
    channelsCreateChannelMethods.onAnswer = &TelegramApi::onChannelsCreateChannelAnswer;
    channelsCreateChannelMethods.onError = &TelegramApi::onChannelsCreateChannelError;
    channelsEditAboutMethods.onAnswer = &TelegramApi::onChannelsEditAboutAnswer;
    channelsEditAboutMethods.onError = &TelegramApi::onChannelsEditAboutError;
    channelsEditAdminMethods.onAnswer = &TelegramApi::onChannelsEditAdminAnswer;
    channelsEditAdminMethods.onError = &TelegramApi::onChannelsEditAdminError;
    channelsEditTitleMethods.onAnswer = &TelegramApi::onChannelsEditTitleAnswer;
    channelsEditTitleMethods.onError = &TelegramApi::onChannelsEditTitleError;
    channelsEditPhotoMethods.onAnswer = &TelegramApi::onChannelsEditPhotoAnswer;
    channelsEditPhotoMethods.onError = &TelegramApi::onChannelsEditPhotoError;
    channelsCheckUsernameMethods.onAnswer = &TelegramApi::onChannelsCheckUsernameAnswer;
    channelsCheckUsernameMethods.onError = &TelegramApi::onChannelsCheckUsernameError;
    channelsUpdateUsernameMethods.onAnswer = &TelegramApi::onChannelsUpdateUsernameAnswer;
    channelsUpdateUsernameMethods.onError = &TelegramApi::onChannelsUpdateUsernameError;
    channelsJoinChannelMethods.onAnswer = &TelegramApi::onChannelsJoinChannelAnswer;
    channelsJoinChannelMethods.onError = &TelegramApi::onChannelsJoinChannelError;
    channelsLeaveChannelMethods.onAnswer = &TelegramApi::onChannelsLeaveChannelAnswer;
    channelsLeaveChannelMethods.onError = &TelegramApi::onChannelsLeaveChannelError;
    channelsInviteToChannelMethods.onAnswer = &TelegramApi::onChannelsInviteToChannelAnswer;
    channelsInviteToChannelMethods.onError = &TelegramApi::onChannelsInviteToChannelError;
    channelsExportInviteMethods.onAnswer = &TelegramApi::onChannelsExportInviteAnswer;
    channelsExportInviteMethods.onError = &TelegramApi::onChannelsExportInviteError;
    channelsDeleteChannelMethods.onAnswer = &TelegramApi::onChannelsDeleteChannelAnswer;
    channelsDeleteChannelMethods.onError = &TelegramApi::onChannelsDeleteChannelError;
    channelsToggleInvitesMethods.onAnswer = &TelegramApi::onChannelsToggleInvitesAnswer;
    channelsToggleInvitesMethods.onError = &TelegramApi::onChannelsToggleInvitesError;
    channelsExportMessageLinkMethods.onAnswer = &TelegramApi::onChannelsExportMessageLinkAnswer;
    channelsExportMessageLinkMethods.onError = &TelegramApi::onChannelsExportMessageLinkError;
    channelsToggleSignaturesMethods.onAnswer = &TelegramApi::onChannelsToggleSignaturesAnswer;
    channelsToggleSignaturesMethods.onError = &TelegramApi::onChannelsToggleSignaturesError;
    channelsUpdatePinnedMessageMethods.onAnswer = &TelegramApi::onChannelsUpdatePinnedMessageAnswer;
    channelsUpdatePinnedMessageMethods.onError = &TelegramApi::onChannelsUpdatePinnedMessageError;
    channelsGetAdminedPublicChannelsMethods.onAnswer = &TelegramApi::onChannelsGetAdminedPublicChannelsAnswer;
    channelsGetAdminedPublicChannelsMethods.onError = &TelegramApi::onChannelsGetAdminedPublicChannelsError;
    channelsEditBannedMethods.onAnswer = &TelegramApi::onChannelsEditBannedAnswer;
    channelsEditBannedMethods.onError = &TelegramApi::onChannelsEditBannedError;
    channelsGetAdminLogMethods.onAnswer = &TelegramApi::onChannelsGetAdminLogAnswer;
    channelsGetAdminLogMethods.onError = &TelegramApi::onChannelsGetAdminLogError;

    contactsGetStatusesMethods.onAnswer = &TelegramApi::onContactsGetStatusesAnswer;
    contactsGetStatusesMethods.onError = &TelegramApi::onContactsGetStatusesError;
    contactsGetContactsMethods.onAnswer = &TelegramApi::onContactsGetContactsAnswer;
    contactsGetContactsMethods.onError = &TelegramApi::onContactsGetContactsError;
    contactsImportContactsMethods.onAnswer = &TelegramApi::onContactsImportContactsAnswer;
    contactsImportContactsMethods.onError = &TelegramApi::onContactsImportContactsError;
    contactsDeleteContactMethods.onAnswer = &TelegramApi::onContactsDeleteContactAnswer;
    contactsDeleteContactMethods.onError = &TelegramApi::onContactsDeleteContactError;
    contactsDeleteContactsMethods.onAnswer = &TelegramApi::onContactsDeleteContactsAnswer;
    contactsDeleteContactsMethods.onError = &TelegramApi::onContactsDeleteContactsError;
    contactsBlockMethods.onAnswer = &TelegramApi::onContactsBlockAnswer;
    contactsBlockMethods.onError = &TelegramApi::onContactsBlockError;
    contactsUnblockMethods.onAnswer = &TelegramApi::onContactsUnblockAnswer;
    contactsUnblockMethods.onError = &TelegramApi::onContactsUnblockError;
    contactsGetBlockedMethods.onAnswer = &TelegramApi::onContactsGetBlockedAnswer;
    contactsGetBlockedMethods.onError = &TelegramApi::onContactsGetBlockedError;
    contactsExportCardMethods.onAnswer = &TelegramApi::onContactsExportCardAnswer;
    contactsExportCardMethods.onError = &TelegramApi::onContactsExportCardError;
    contactsImportCardMethods.onAnswer = &TelegramApi::onContactsImportCardAnswer;
    contactsImportCardMethods.onError = &TelegramApi::onContactsImportCardError;
    contactsSearchMethods.onAnswer = &TelegramApi::onContactsSearchAnswer;
    contactsSearchMethods.onError = &TelegramApi::onContactsSearchError;
    contactsResolveUsernameMethods.onAnswer = &TelegramApi::onContactsResolveUsernameAnswer;
    contactsResolveUsernameMethods.onError = &TelegramApi::onContactsResolveUsernameError;
    contactsGetTopPeersMethods.onAnswer = &TelegramApi::onContactsGetTopPeersAnswer;
    contactsGetTopPeersMethods.onError = &TelegramApi::onContactsGetTopPeersError;
    contactsResetTopPeerRatingMethods.onAnswer = &TelegramApi::onContactsResetTopPeerRatingAnswer;
    contactsResetTopPeerRatingMethods.onError = &TelegramApi::onContactsResetTopPeerRatingError;

    helpGetConfigMethods.onAnswer = &TelegramApi::onHelpGetConfigAnswer;
    helpGetConfigMethods.onError = &TelegramApi::onHelpGetConfigError;
    helpGetNearestDcMethods.onAnswer = &TelegramApi::onHelpGetNearestDcAnswer;
    helpGetNearestDcMethods.onError = &TelegramApi::onHelpGetNearestDcError;
    helpGetAppUpdateMethods.onAnswer = &TelegramApi::onHelpGetAppUpdateAnswer;
    helpGetAppUpdateMethods.onError = &TelegramApi::onHelpGetAppUpdateError;
    helpSaveAppLogMethods.onAnswer = &TelegramApi::onHelpSaveAppLogAnswer;
    helpSaveAppLogMethods.onError = &TelegramApi::onHelpSaveAppLogError;
    helpGetInviteTextMethods.onAnswer = &TelegramApi::onHelpGetInviteTextAnswer;
    helpGetInviteTextMethods.onError = &TelegramApi::onHelpGetInviteTextError;
    helpGetSupportMethods.onAnswer = &TelegramApi::onHelpGetSupportAnswer;
    helpGetSupportMethods.onError = &TelegramApi::onHelpGetSupportError;
    helpGetAppChangelogMethods.onAnswer = &TelegramApi::onHelpGetAppChangelogAnswer;
    helpGetAppChangelogMethods.onError = &TelegramApi::onHelpGetAppChangelogError;
    helpGetTermsOfServiceMethods.onAnswer = &TelegramApi::onHelpGetTermsOfServiceAnswer;
    helpGetTermsOfServiceMethods.onError = &TelegramApi::onHelpGetTermsOfServiceError;
    helpSetBotUpdatesStatusMethods.onAnswer = &TelegramApi::onHelpSetBotUpdatesStatusAnswer;
    helpSetBotUpdatesStatusMethods.onError = &TelegramApi::onHelpSetBotUpdatesStatusError;
    helpGetCdnConfigMethods.onAnswer = &TelegramApi::onHelpGetCdnConfigAnswer;
    helpGetCdnConfigMethods.onError = &TelegramApi::onHelpGetCdnConfigError;

    langpackGetLangPackMethods.onAnswer = &TelegramApi::onLangpackGetLangPackAnswer;
    langpackGetLangPackMethods.onError = &TelegramApi::onLangpackGetLangPackError;
    langpackGetStringsMethods.onAnswer = &TelegramApi::onLangpackGetStringsAnswer;
    langpackGetStringsMethods.onError = &TelegramApi::onLangpackGetStringsError;
    langpackGetDifferenceMethods.onAnswer = &TelegramApi::onLangpackGetDifferenceAnswer;
    langpackGetDifferenceMethods.onError = &TelegramApi::onLangpackGetDifferenceError;
    langpackGetLanguagesMethods.onAnswer = &TelegramApi::onLangpackGetLanguagesAnswer;
    langpackGetLanguagesMethods.onError = &TelegramApi::onLangpackGetLanguagesError;

    messagesGetMessagesMethods.onAnswer = &TelegramApi::onMessagesGetMessagesAnswer;
    messagesGetMessagesMethods.onError = &TelegramApi::onMessagesGetMessagesError;
    messagesGetDialogsMethods.onAnswer = &TelegramApi::onMessagesGetDialogsAnswer;
    messagesGetDialogsMethods.onError = &TelegramApi::onMessagesGetDialogsError;
    messagesGetHistoryMethods.onAnswer = &TelegramApi::onMessagesGetHistoryAnswer;
    messagesGetHistoryMethods.onError = &TelegramApi::onMessagesGetHistoryError;
    messagesSearchMethods.onAnswer = &TelegramApi::onMessagesSearchAnswer;
    messagesSearchMethods.onError = &TelegramApi::onMessagesSearchError;
    messagesReadHistoryMethods.onAnswer = &TelegramApi::onMessagesReadHistoryAnswer;
    messagesReadHistoryMethods.onError = &TelegramApi::onMessagesReadHistoryError;
    messagesDeleteHistoryMethods.onAnswer = &TelegramApi::onMessagesDeleteHistoryAnswer;
    messagesDeleteHistoryMethods.onError = &TelegramApi::onMessagesDeleteHistoryError;
    messagesDeleteMessagesMethods.onAnswer = &TelegramApi::onMessagesDeleteMessagesAnswer;
    messagesDeleteMessagesMethods.onError = &TelegramApi::onMessagesDeleteMessagesError;
    messagesReceivedMessagesMethods.onAnswer = &TelegramApi::onMessagesReceivedMessagesAnswer;
    messagesReceivedMessagesMethods.onError = &TelegramApi::onMessagesReceivedMessagesError;
    messagesSetTypingMethods.onAnswer = &TelegramApi::onMessagesSetTypingAnswer;
    messagesSetTypingMethods.onError = &TelegramApi::onMessagesSetTypingError;
    messagesSendMessageMethods.onAnswer = &TelegramApi::onMessagesSendMessageAnswer;
    messagesSendMessageMethods.onError = &TelegramApi::onMessagesSendMessageError;
    messagesSendMediaMethods.onAnswer = &TelegramApi::onMessagesSendMediaAnswer;
    messagesSendMediaMethods.onError = &TelegramApi::onMessagesSendMediaError;
    messagesForwardMessagesMethods.onAnswer = &TelegramApi::onMessagesForwardMessagesAnswer;
    messagesForwardMessagesMethods.onError = &TelegramApi::onMessagesForwardMessagesError;
    messagesReportSpamMethods.onAnswer = &TelegramApi::onMessagesReportSpamAnswer;
    messagesReportSpamMethods.onError = &TelegramApi::onMessagesReportSpamError;
    messagesHideReportSpamMethods.onAnswer = &TelegramApi::onMessagesHideReportSpamAnswer;
    messagesHideReportSpamMethods.onError = &TelegramApi::onMessagesHideReportSpamError;
    messagesGetPeerSettingsMethods.onAnswer = &TelegramApi::onMessagesGetPeerSettingsAnswer;
    messagesGetPeerSettingsMethods.onError = &TelegramApi::onMessagesGetPeerSettingsError;
    messagesGetChatsMethods.onAnswer = &TelegramApi::onMessagesGetChatsAnswer;
    messagesGetChatsMethods.onError = &TelegramApi::onMessagesGetChatsError;
    messagesGetFullChatMethods.onAnswer = &TelegramApi::onMessagesGetFullChatAnswer;
    messagesGetFullChatMethods.onError = &TelegramApi::onMessagesGetFullChatError;
    messagesEditChatTitleMethods.onAnswer = &TelegramApi::onMessagesEditChatTitleAnswer;
    messagesEditChatTitleMethods.onError = &TelegramApi::onMessagesEditChatTitleError;
    messagesEditChatPhotoMethods.onAnswer = &TelegramApi::onMessagesEditChatPhotoAnswer;
    messagesEditChatPhotoMethods.onError = &TelegramApi::onMessagesEditChatPhotoError;
    messagesAddChatUserMethods.onAnswer = &TelegramApi::onMessagesAddChatUserAnswer;
    messagesAddChatUserMethods.onError = &TelegramApi::onMessagesAddChatUserError;
    messagesDeleteChatUserMethods.onAnswer = &TelegramApi::onMessagesDeleteChatUserAnswer;
    messagesDeleteChatUserMethods.onError = &TelegramApi::onMessagesDeleteChatUserError;
    messagesCreateChatMethods.onAnswer = &TelegramApi::onMessagesCreateChatAnswer;
    messagesCreateChatMethods.onError = &TelegramApi::onMessagesCreateChatError;
    messagesForwardMessageMethods.onAnswer = &TelegramApi::onMessagesForwardMessageAnswer;
    messagesForwardMessageMethods.onError = &TelegramApi::onMessagesForwardMessageError;
    messagesGetDhConfigMethods.onAnswer = &TelegramApi::onMessagesGetDhConfigAnswer;
    messagesGetDhConfigMethods.onError = &TelegramApi::onMessagesGetDhConfigError;
    messagesRequestEncryptionMethods.onAnswer = &TelegramApi::onMessagesRequestEncryptionAnswer;
    messagesRequestEncryptionMethods.onError = &TelegramApi::onMessagesRequestEncryptionError;
    messagesAcceptEncryptionMethods.onAnswer = &TelegramApi::onMessagesAcceptEncryptionAnswer;
    messagesAcceptEncryptionMethods.onError = &TelegramApi::onMessagesAcceptEncryptionError;
    messagesDiscardEncryptionMethods.onAnswer = &TelegramApi::onMessagesDiscardEncryptionAnswer;
    messagesDiscardEncryptionMethods.onError = &TelegramApi::onMessagesDiscardEncryptionError;
    messagesSetEncryptedTypingMethods.onAnswer = &TelegramApi::onMessagesSetEncryptedTypingAnswer;
    messagesSetEncryptedTypingMethods.onError = &TelegramApi::onMessagesSetEncryptedTypingError;
    messagesReadEncryptedHistoryMethods.onAnswer = &TelegramApi::onMessagesReadEncryptedHistoryAnswer;
    messagesReadEncryptedHistoryMethods.onError = &TelegramApi::onMessagesReadEncryptedHistoryError;
    messagesSendEncryptedMethods.onAnswer = &TelegramApi::onMessagesSendEncryptedAnswer;
    messagesSendEncryptedMethods.onError = &TelegramApi::onMessagesSendEncryptedError;
    messagesSendEncryptedFileMethods.onAnswer = &TelegramApi::onMessagesSendEncryptedFileAnswer;
    messagesSendEncryptedFileMethods.onError = &TelegramApi::onMessagesSendEncryptedFileError;
    messagesSendEncryptedServiceMethods.onAnswer = &TelegramApi::onMessagesSendEncryptedServiceAnswer;
    messagesSendEncryptedServiceMethods.onError = &TelegramApi::onMessagesSendEncryptedServiceError;
    messagesReceivedQueueMethods.onAnswer = &TelegramApi::onMessagesReceivedQueueAnswer;
    messagesReceivedQueueMethods.onError = &TelegramApi::onMessagesReceivedQueueError;
    messagesReportEncryptedSpamMethods.onAnswer = &TelegramApi::onMessagesReportEncryptedSpamAnswer;
    messagesReportEncryptedSpamMethods.onError = &TelegramApi::onMessagesReportEncryptedSpamError;
    messagesReadMessageContentsMethods.onAnswer = &TelegramApi::onMessagesReadMessageContentsAnswer;
    messagesReadMessageContentsMethods.onError = &TelegramApi::onMessagesReadMessageContentsError;
    messagesGetAllStickersMethods.onAnswer = &TelegramApi::onMessagesGetAllStickersAnswer;
    messagesGetAllStickersMethods.onError = &TelegramApi::onMessagesGetAllStickersError;
    messagesGetWebPagePreviewMethods.onAnswer = &TelegramApi::onMessagesGetWebPagePreviewAnswer;
    messagesGetWebPagePreviewMethods.onError = &TelegramApi::onMessagesGetWebPagePreviewError;
    messagesExportChatInviteMethods.onAnswer = &TelegramApi::onMessagesExportChatInviteAnswer;
    messagesExportChatInviteMethods.onError = &TelegramApi::onMessagesExportChatInviteError;
    messagesCheckChatInviteMethods.onAnswer = &TelegramApi::onMessagesCheckChatInviteAnswer;
    messagesCheckChatInviteMethods.onError = &TelegramApi::onMessagesCheckChatInviteError;
    messagesImportChatInviteMethods.onAnswer = &TelegramApi::onMessagesImportChatInviteAnswer;
    messagesImportChatInviteMethods.onError = &TelegramApi::onMessagesImportChatInviteError;
    messagesGetStickerSetMethods.onAnswer = &TelegramApi::onMessagesGetStickerSetAnswer;
    messagesGetStickerSetMethods.onError = &TelegramApi::onMessagesGetStickerSetError;
    messagesInstallStickerSetMethods.onAnswer = &TelegramApi::onMessagesInstallStickerSetAnswer;
    messagesInstallStickerSetMethods.onError = &TelegramApi::onMessagesInstallStickerSetError;
    messagesUninstallStickerSetMethods.onAnswer = &TelegramApi::onMessagesUninstallStickerSetAnswer;
    messagesUninstallStickerSetMethods.onError = &TelegramApi::onMessagesUninstallStickerSetError;
    messagesStartBotMethods.onAnswer = &TelegramApi::onMessagesStartBotAnswer;
    messagesStartBotMethods.onError = &TelegramApi::onMessagesStartBotError;
    messagesGetMessagesViewsMethods.onAnswer = &TelegramApi::onMessagesGetMessagesViewsAnswer;
    messagesGetMessagesViewsMethods.onError = &TelegramApi::onMessagesGetMessagesViewsError;
    messagesToggleChatAdminsMethods.onAnswer = &TelegramApi::onMessagesToggleChatAdminsAnswer;
    messagesToggleChatAdminsMethods.onError = &TelegramApi::onMessagesToggleChatAdminsError;
    messagesEditChatAdminMethods.onAnswer = &TelegramApi::onMessagesEditChatAdminAnswer;
    messagesEditChatAdminMethods.onError = &TelegramApi::onMessagesEditChatAdminError;
    messagesMigrateChatMethods.onAnswer = &TelegramApi::onMessagesMigrateChatAnswer;
    messagesMigrateChatMethods.onError = &TelegramApi::onMessagesMigrateChatError;
    messagesSearchGlobalMethods.onAnswer = &TelegramApi::onMessagesSearchGlobalAnswer;
    messagesSearchGlobalMethods.onError = &TelegramApi::onMessagesSearchGlobalError;
    messagesReorderStickerSetsMethods.onAnswer = &TelegramApi::onMessagesReorderStickerSetsAnswer;
    messagesReorderStickerSetsMethods.onError = &TelegramApi::onMessagesReorderStickerSetsError;
    messagesGetDocumentByHashMethods.onAnswer = &TelegramApi::onMessagesGetDocumentByHashAnswer;
    messagesGetDocumentByHashMethods.onError = &TelegramApi::onMessagesGetDocumentByHashError;
    messagesSearchGifsMethods.onAnswer = &TelegramApi::onMessagesSearchGifsAnswer;
    messagesSearchGifsMethods.onError = &TelegramApi::onMessagesSearchGifsError;
    messagesGetSavedGifsMethods.onAnswer = &TelegramApi::onMessagesGetSavedGifsAnswer;
    messagesGetSavedGifsMethods.onError = &TelegramApi::onMessagesGetSavedGifsError;
    messagesSaveGifMethods.onAnswer = &TelegramApi::onMessagesSaveGifAnswer;
    messagesSaveGifMethods.onError = &TelegramApi::onMessagesSaveGifError;
    messagesGetInlineBotResultsMethods.onAnswer = &TelegramApi::onMessagesGetInlineBotResultsAnswer;
    messagesGetInlineBotResultsMethods.onError = &TelegramApi::onMessagesGetInlineBotResultsError;
    messagesSetInlineBotResultsMethods.onAnswer = &TelegramApi::onMessagesSetInlineBotResultsAnswer;
    messagesSetInlineBotResultsMethods.onError = &TelegramApi::onMessagesSetInlineBotResultsError;
    messagesSendInlineBotResultMethods.onAnswer = &TelegramApi::onMessagesSendInlineBotResultAnswer;
    messagesSendInlineBotResultMethods.onError = &TelegramApi::onMessagesSendInlineBotResultError;
    messagesGetMessageEditDataMethods.onAnswer = &TelegramApi::onMessagesGetMessageEditDataAnswer;
    messagesGetMessageEditDataMethods.onError = &TelegramApi::onMessagesGetMessageEditDataError;
    messagesEditMessageMethods.onAnswer = &TelegramApi::onMessagesEditMessageAnswer;
    messagesEditMessageMethods.onError = &TelegramApi::onMessagesEditMessageError;
    messagesEditInlineBotMessageMethods.onAnswer = &TelegramApi::onMessagesEditInlineBotMessageAnswer;
    messagesEditInlineBotMessageMethods.onError = &TelegramApi::onMessagesEditInlineBotMessageError;
    messagesGetBotCallbackAnswerMethods.onAnswer = &TelegramApi::onMessagesGetBotCallbackAnswerAnswer;
    messagesGetBotCallbackAnswerMethods.onError = &TelegramApi::onMessagesGetBotCallbackAnswerError;
    messagesSetBotCallbackAnswerMethods.onAnswer = &TelegramApi::onMessagesSetBotCallbackAnswerAnswer;
    messagesSetBotCallbackAnswerMethods.onError = &TelegramApi::onMessagesSetBotCallbackAnswerError;
    messagesGetPeerDialogsMethods.onAnswer = &TelegramApi::onMessagesGetPeerDialogsAnswer;
    messagesGetPeerDialogsMethods.onError = &TelegramApi::onMessagesGetPeerDialogsError;
    messagesSaveDraftMethods.onAnswer = &TelegramApi::onMessagesSaveDraftAnswer;
    messagesSaveDraftMethods.onError = &TelegramApi::onMessagesSaveDraftError;
    messagesGetAllDraftsMethods.onAnswer = &TelegramApi::onMessagesGetAllDraftsAnswer;
    messagesGetAllDraftsMethods.onError = &TelegramApi::onMessagesGetAllDraftsError;
    messagesGetFeaturedStickersMethods.onAnswer = &TelegramApi::onMessagesGetFeaturedStickersAnswer;
    messagesGetFeaturedStickersMethods.onError = &TelegramApi::onMessagesGetFeaturedStickersError;
    messagesReadFeaturedStickersMethods.onAnswer = &TelegramApi::onMessagesReadFeaturedStickersAnswer;
    messagesReadFeaturedStickersMethods.onError = &TelegramApi::onMessagesReadFeaturedStickersError;
    messagesGetRecentStickersMethods.onAnswer = &TelegramApi::onMessagesGetRecentStickersAnswer;
    messagesGetRecentStickersMethods.onError = &TelegramApi::onMessagesGetRecentStickersError;
    messagesSaveRecentStickerMethods.onAnswer = &TelegramApi::onMessagesSaveRecentStickerAnswer;
    messagesSaveRecentStickerMethods.onError = &TelegramApi::onMessagesSaveRecentStickerError;
    messagesClearRecentStickersMethods.onAnswer = &TelegramApi::onMessagesClearRecentStickersAnswer;
    messagesClearRecentStickersMethods.onError = &TelegramApi::onMessagesClearRecentStickersError;
    messagesGetArchivedStickersMethods.onAnswer = &TelegramApi::onMessagesGetArchivedStickersAnswer;
    messagesGetArchivedStickersMethods.onError = &TelegramApi::onMessagesGetArchivedStickersError;
    messagesGetMaskStickersMethods.onAnswer = &TelegramApi::onMessagesGetMaskStickersAnswer;
    messagesGetMaskStickersMethods.onError = &TelegramApi::onMessagesGetMaskStickersError;
    messagesGetAttachedStickersMethods.onAnswer = &TelegramApi::onMessagesGetAttachedStickersAnswer;
    messagesGetAttachedStickersMethods.onError = &TelegramApi::onMessagesGetAttachedStickersError;
    messagesSetGameScoreMethods.onAnswer = &TelegramApi::onMessagesSetGameScoreAnswer;
    messagesSetGameScoreMethods.onError = &TelegramApi::onMessagesSetGameScoreError;
    messagesSetInlineGameScoreMethods.onAnswer = &TelegramApi::onMessagesSetInlineGameScoreAnswer;
    messagesSetInlineGameScoreMethods.onError = &TelegramApi::onMessagesSetInlineGameScoreError;
    messagesGetGameHighScoresMethods.onAnswer = &TelegramApi::onMessagesGetGameHighScoresAnswer;
    messagesGetGameHighScoresMethods.onError = &TelegramApi::onMessagesGetGameHighScoresError;
    messagesGetInlineGameHighScoresMethods.onAnswer = &TelegramApi::onMessagesGetInlineGameHighScoresAnswer;
    messagesGetInlineGameHighScoresMethods.onError = &TelegramApi::onMessagesGetInlineGameHighScoresError;
    messagesGetCommonChatsMethods.onAnswer = &TelegramApi::onMessagesGetCommonChatsAnswer;
    messagesGetCommonChatsMethods.onError = &TelegramApi::onMessagesGetCommonChatsError;
    messagesGetAllChatsMethods.onAnswer = &TelegramApi::onMessagesGetAllChatsAnswer;
    messagesGetAllChatsMethods.onError = &TelegramApi::onMessagesGetAllChatsError;
    messagesGetWebPageMethods.onAnswer = &TelegramApi::onMessagesGetWebPageAnswer;
    messagesGetWebPageMethods.onError = &TelegramApi::onMessagesGetWebPageError;
    messagesToggleDialogPinMethods.onAnswer = &TelegramApi::onMessagesToggleDialogPinAnswer;
    messagesToggleDialogPinMethods.onError = &TelegramApi::onMessagesToggleDialogPinError;
    messagesReorderPinnedDialogsMethods.onAnswer = &TelegramApi::onMessagesReorderPinnedDialogsAnswer;
    messagesReorderPinnedDialogsMethods.onError = &TelegramApi::onMessagesReorderPinnedDialogsError;
    messagesGetPinnedDialogsMethods.onAnswer = &TelegramApi::onMessagesGetPinnedDialogsAnswer;
    messagesGetPinnedDialogsMethods.onError = &TelegramApi::onMessagesGetPinnedDialogsError;
    messagesSetBotShippingResultsMethods.onAnswer = &TelegramApi::onMessagesSetBotShippingResultsAnswer;
    messagesSetBotShippingResultsMethods.onError = &TelegramApi::onMessagesSetBotShippingResultsError;
    messagesSetBotPrecheckoutResultsMethods.onAnswer = &TelegramApi::onMessagesSetBotPrecheckoutResultsAnswer;
    messagesSetBotPrecheckoutResultsMethods.onError = &TelegramApi::onMessagesSetBotPrecheckoutResultsError;
    messagesUploadMediaMethods.onAnswer = &TelegramApi::onMessagesUploadMediaAnswer;
    messagesUploadMediaMethods.onError = &TelegramApi::onMessagesUploadMediaError;

    paymentsGetPaymentFormMethods.onAnswer = &TelegramApi::onPaymentsGetPaymentFormAnswer;
    paymentsGetPaymentFormMethods.onError = &TelegramApi::onPaymentsGetPaymentFormError;
    paymentsGetPaymentReceiptMethods.onAnswer = &TelegramApi::onPaymentsGetPaymentReceiptAnswer;
    paymentsGetPaymentReceiptMethods.onError = &TelegramApi::onPaymentsGetPaymentReceiptError;
    paymentsValidateRequestedInfoMethods.onAnswer = &TelegramApi::onPaymentsValidateRequestedInfoAnswer;
    paymentsValidateRequestedInfoMethods.onError = &TelegramApi::onPaymentsValidateRequestedInfoError;
    paymentsSendPaymentFormMethods.onAnswer = &TelegramApi::onPaymentsSendPaymentFormAnswer;
    paymentsSendPaymentFormMethods.onError = &TelegramApi::onPaymentsSendPaymentFormError;
    paymentsGetSavedInfoMethods.onAnswer = &TelegramApi::onPaymentsGetSavedInfoAnswer;
    paymentsGetSavedInfoMethods.onError = &TelegramApi::onPaymentsGetSavedInfoError;
    paymentsClearSavedInfoMethods.onAnswer = &TelegramApi::onPaymentsClearSavedInfoAnswer;
    paymentsClearSavedInfoMethods.onError = &TelegramApi::onPaymentsClearSavedInfoError;

    phoneGetCallConfigMethods.onAnswer = &TelegramApi::onPhoneGetCallConfigAnswer;
    phoneGetCallConfigMethods.onError = &TelegramApi::onPhoneGetCallConfigError;
    phoneRequestCallMethods.onAnswer = &TelegramApi::onPhoneRequestCallAnswer;
    phoneRequestCallMethods.onError = &TelegramApi::onPhoneRequestCallError;
    phoneAcceptCallMethods.onAnswer = &TelegramApi::onPhoneAcceptCallAnswer;
    phoneAcceptCallMethods.onError = &TelegramApi::onPhoneAcceptCallError;
    phoneConfirmCallMethods.onAnswer = &TelegramApi::onPhoneConfirmCallAnswer;
    phoneConfirmCallMethods.onError = &TelegramApi::onPhoneConfirmCallError;
    phoneReceivedCallMethods.onAnswer = &TelegramApi::onPhoneReceivedCallAnswer;
    phoneReceivedCallMethods.onError = &TelegramApi::onPhoneReceivedCallError;
    phoneDiscardCallMethods.onAnswer = &TelegramApi::onPhoneDiscardCallAnswer;
    phoneDiscardCallMethods.onError = &TelegramApi::onPhoneDiscardCallError;
    phoneSetCallRatingMethods.onAnswer = &TelegramApi::onPhoneSetCallRatingAnswer;
    phoneSetCallRatingMethods.onError = &TelegramApi::onPhoneSetCallRatingError;
    phoneSaveCallDebugMethods.onAnswer = &TelegramApi::onPhoneSaveCallDebugAnswer;
    phoneSaveCallDebugMethods.onError = &TelegramApi::onPhoneSaveCallDebugError;

    photosUpdateProfilePhotoMethods.onAnswer = &TelegramApi::onPhotosUpdateProfilePhotoAnswer;
    photosUpdateProfilePhotoMethods.onError = &TelegramApi::onPhotosUpdateProfilePhotoError;
    photosUploadProfilePhotoMethods.onAnswer = &TelegramApi::onPhotosUploadProfilePhotoAnswer;
    photosUploadProfilePhotoMethods.onError = &TelegramApi::onPhotosUploadProfilePhotoError;
    photosDeletePhotosMethods.onAnswer = &TelegramApi::onPhotosDeletePhotosAnswer;
    photosDeletePhotosMethods.onError = &TelegramApi::onPhotosDeletePhotosError;
    photosGetUserPhotosMethods.onAnswer = &TelegramApi::onPhotosGetUserPhotosAnswer;
    photosGetUserPhotosMethods.onError = &TelegramApi::onPhotosGetUserPhotosError;

    stickersCreateStickerSetMethods.onAnswer = &TelegramApi::onStickersCreateStickerSetAnswer;
    stickersCreateStickerSetMethods.onError = &TelegramApi::onStickersCreateStickerSetError;
    stickersRemoveStickerFromSetMethods.onAnswer = &TelegramApi::onStickersRemoveStickerFromSetAnswer;
    stickersRemoveStickerFromSetMethods.onError = &TelegramApi::onStickersRemoveStickerFromSetError;
    stickersChangeStickerPositionMethods.onAnswer = &TelegramApi::onStickersChangeStickerPositionAnswer;
    stickersChangeStickerPositionMethods.onError = &TelegramApi::onStickersChangeStickerPositionError;
    stickersAddStickerToSetMethods.onAnswer = &TelegramApi::onStickersAddStickerToSetAnswer;
    stickersAddStickerToSetMethods.onError = &TelegramApi::onStickersAddStickerToSetError;

    updatesGetStateMethods.onAnswer = &TelegramApi::onUpdatesGetStateAnswer;
    updatesGetStateMethods.onError = &TelegramApi::onUpdatesGetStateError;
    updatesGetDifferenceMethods.onAnswer = &TelegramApi::onUpdatesGetDifferenceAnswer;
    updatesGetDifferenceMethods.onError = &TelegramApi::onUpdatesGetDifferenceError;
    updatesGetChannelDifferenceMethods.onAnswer = &TelegramApi::onUpdatesGetChannelDifferenceAnswer;
    updatesGetChannelDifferenceMethods.onError = &TelegramApi::onUpdatesGetChannelDifferenceError;

    uploadSaveFilePartMethods.onAnswer = &TelegramApi::onUploadSaveFilePartAnswer;
    uploadSaveFilePartMethods.onError = &TelegramApi::onUploadSaveFilePartError;
    uploadGetFileMethods.onAnswer = &TelegramApi::onUploadGetFileAnswer;
    uploadGetFileMethods.onError = &TelegramApi::onUploadGetFileError;
    uploadSaveBigFilePartMethods.onAnswer = &TelegramApi::onUploadSaveBigFilePartAnswer;
    uploadSaveBigFilePartMethods.onError = &TelegramApi::onUploadSaveBigFilePartError;
    uploadGetWebFileMethods.onAnswer = &TelegramApi::onUploadGetWebFileAnswer;
    uploadGetWebFileMethods.onError = &TelegramApi::onUploadGetWebFileError;
    uploadGetCdnFileMethods.onAnswer = &TelegramApi::onUploadGetCdnFileAnswer;
    uploadGetCdnFileMethods.onError = &TelegramApi::onUploadGetCdnFileError;
    uploadReuploadCdnFileMethods.onAnswer = &TelegramApi::onUploadReuploadCdnFileAnswer;
    uploadReuploadCdnFileMethods.onError = &TelegramApi::onUploadReuploadCdnFileError;

    usersGetUsersMethods.onAnswer = &TelegramApi::onUsersGetUsersAnswer;
    usersGetUsersMethods.onError = &TelegramApi::onUsersGetUsersError;
    usersGetFullUserMethods.onAnswer = &TelegramApi::onUsersGetFullUserAnswer;
    usersGetFullUserMethods.onError = &TelegramApi::onUsersGetFullUserError;

}

TelegramApi::~TelegramApi() {
}

qint64 TelegramApi::accountRegisterDevice(qint32 token_type, const QString &token, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::registerDevice(&p, token_type, token);
    return session->sendQuery(p, &accountRegisterDeviceMethods, attachedData, "Account->registerDevice" );
}

void TelegramApi::onAccountRegisterDeviceAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::registerDeviceResult(&inboundPkt);
    Q_EMIT accountRegisterDeviceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountRegisterDeviceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountRegisterDeviceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUnregisterDevice(qint32 token_type, const QString &token, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::unregisterDevice(&p, token_type, token);
    return session->sendQuery(p, &accountUnregisterDeviceMethods, attachedData, "Account->unregisterDevice" );
}

void TelegramApi::onAccountUnregisterDeviceAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::unregisterDeviceResult(&inboundPkt);
    Q_EMIT accountUnregisterDeviceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUnregisterDeviceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUnregisterDeviceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateNotifySettings(const InputNotifyPeer &peer, const InputPeerNotifySettings &settings, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateNotifySettings(&p, peer, settings);
    return session->sendQuery(p, &accountUpdateNotifySettingsMethods, attachedData, "Account->updateNotifySettings" );
}

void TelegramApi::onAccountUpdateNotifySettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updateNotifySettingsResult(&inboundPkt);
    Q_EMIT accountUpdateNotifySettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateNotifySettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateNotifySettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetNotifySettings(const InputNotifyPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getNotifySettings(&p, peer);
    return session->sendQuery(p, &accountGetNotifySettingsMethods, attachedData, "Account->getNotifySettings" );
}

void TelegramApi::onAccountGetNotifySettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const PeerNotifySettings &result = Functions::Account::getNotifySettingsResult(&inboundPkt);
    if(result.error())
        onAccountGetNotifySettingsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetNotifySettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetNotifySettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetNotifySettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountResetNotifySettings(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::resetNotifySettings(&p);
    return session->sendQuery(p, &accountResetNotifySettingsMethods, attachedData, "Account->resetNotifySettings" );
}

void TelegramApi::onAccountResetNotifySettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::resetNotifySettingsResult(&inboundPkt);
    Q_EMIT accountResetNotifySettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountResetNotifySettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountResetNotifySettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateProfile(const QString &first_name, const QString &last_name, const QString &about, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateProfile(&p, first_name, last_name, about);
    return session->sendQuery(p, &accountUpdateProfileMethods, attachedData, "Account->updateProfile" );
}

void TelegramApi::onAccountUpdateProfileAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Account::updateProfileResult(&inboundPkt);
    if(result.error())
        onAccountUpdateProfileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountUpdateProfileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateProfileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateProfileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateStatus(bool offline, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateStatus(&p, offline);
    return session->sendQuery(p, &accountUpdateStatusMethods, attachedData, "Account->updateStatus" );
}

void TelegramApi::onAccountUpdateStatusAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updateStatusResult(&inboundPkt);
    Q_EMIT accountUpdateStatusAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateStatusError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateStatusError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetWallPapers(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getWallPapers(&p);
    return session->sendQuery(p, &accountGetWallPapersMethods, attachedData, "Account->getWallPapers" );
}

void TelegramApi::onAccountGetWallPapersAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<WallPaper> &result = Functions::Account::getWallPapersResult(&inboundPkt);
    Q_EMIT accountGetWallPapersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetWallPapersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetWallPapersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountReportPeer(const InputPeer &peer, const ReportReason &reason, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::reportPeer(&p, peer, reason);
    return session->sendQuery(p, &accountReportPeerMethods, attachedData, "Account->reportPeer" );
}

void TelegramApi::onAccountReportPeerAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::reportPeerResult(&inboundPkt);
    Q_EMIT accountReportPeerAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountReportPeerError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountReportPeerError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountCheckUsername(const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::checkUsername(&p, username);
    return session->sendQuery(p, &accountCheckUsernameMethods, attachedData, "Account->checkUsername" );
}

void TelegramApi::onAccountCheckUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::checkUsernameResult(&inboundPkt);
    Q_EMIT accountCheckUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountCheckUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountCheckUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateUsername(const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateUsername(&p, username);
    return session->sendQuery(p, &accountUpdateUsernameMethods, attachedData, "Account->updateUsername" );
}

void TelegramApi::onAccountUpdateUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Account::updateUsernameResult(&inboundPkt);
    if(result.error())
        onAccountUpdateUsernameError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountUpdateUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetPrivacy(const InputPrivacyKey &key, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getPrivacy(&p, key);
    return session->sendQuery(p, &accountGetPrivacyMethods, attachedData, "Account->getPrivacy" );
}

void TelegramApi::onAccountGetPrivacyAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPrivacyRules &result = Functions::Account::getPrivacyResult(&inboundPkt);
    if(result.error())
        onAccountGetPrivacyError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetPrivacyAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetPrivacyError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetPrivacyError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSetPrivacy(const InputPrivacyKey &key, const QList<InputPrivacyRule> &rules, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::setPrivacy(&p, key, rules);
    return session->sendQuery(p, &accountSetPrivacyMethods, attachedData, "Account->setPrivacy" );
}

void TelegramApi::onAccountSetPrivacyAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPrivacyRules &result = Functions::Account::setPrivacyResult(&inboundPkt);
    if(result.error())
        onAccountSetPrivacyError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountSetPrivacyAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSetPrivacyError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSetPrivacyError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountDeleteAccount(const QString &reason, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::deleteAccount(&p, reason);
    return session->sendQuery(p, &accountDeleteAccountMethods, attachedData, "Account->deleteAccount" );
}

void TelegramApi::onAccountDeleteAccountAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::deleteAccountResult(&inboundPkt);
    Q_EMIT accountDeleteAccountAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountDeleteAccountError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountDeleteAccountError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetAccountTTL(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getAccountTTL(&p);
    return session->sendQuery(p, &accountGetAccountTTLMethods, attachedData, "Account->getAccountTTL" );
}

void TelegramApi::onAccountGetAccountTTLAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountDaysTTL &result = Functions::Account::getAccountTTLResult(&inboundPkt);
    if(result.error())
        onAccountGetAccountTTLError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetAccountTTLAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetAccountTTLError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetAccountTTLError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSetAccountTTL(const AccountDaysTTL &ttl, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::setAccountTTL(&p, ttl);
    return session->sendQuery(p, &accountSetAccountTTLMethods, attachedData, "Account->setAccountTTL" );
}

void TelegramApi::onAccountSetAccountTTLAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::setAccountTTLResult(&inboundPkt);
    Q_EMIT accountSetAccountTTLAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSetAccountTTLError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSetAccountTTLError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSendChangePhoneCode(bool allow_flashcall, const QString &phone_number, bool current_number, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::sendChangePhoneCode(&p, allow_flashcall, phone_number, current_number);
    return session->sendQuery(p, &accountSendChangePhoneCodeMethods, attachedData, "Account->sendChangePhoneCode" );
}

void TelegramApi::onAccountSendChangePhoneCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthSentCode &result = Functions::Account::sendChangePhoneCodeResult(&inboundPkt);
    if(result.error())
        onAccountSendChangePhoneCodeError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountSendChangePhoneCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSendChangePhoneCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSendChangePhoneCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountChangePhone(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::changePhone(&p, phone_number, phone_code_hash, phone_code);
    return session->sendQuery(p, &accountChangePhoneMethods, attachedData, "Account->changePhone" );
}

void TelegramApi::onAccountChangePhoneAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Account::changePhoneResult(&inboundPkt);
    if(result.error())
        onAccountChangePhoneError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountChangePhoneAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountChangePhoneError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountChangePhoneError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateDeviceLocked(qint32 period, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateDeviceLocked(&p, period);
    return session->sendQuery(p, &accountUpdateDeviceLockedMethods, attachedData, "Account->updateDeviceLocked" );
}

void TelegramApi::onAccountUpdateDeviceLockedAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updateDeviceLockedResult(&inboundPkt);
    Q_EMIT accountUpdateDeviceLockedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateDeviceLockedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateDeviceLockedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetAuthorizations(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getAuthorizations(&p);
    return session->sendQuery(p, &accountGetAuthorizationsMethods, attachedData, "Account->getAuthorizations" );
}

void TelegramApi::onAccountGetAuthorizationsAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountAuthorizations &result = Functions::Account::getAuthorizationsResult(&inboundPkt);
    if(result.error())
        onAccountGetAuthorizationsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetAuthorizationsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetAuthorizationsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetAuthorizationsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountResetAuthorization(qint64 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::resetAuthorization(&p, hash);
    return session->sendQuery(p, &accountResetAuthorizationMethods, attachedData, "Account->resetAuthorization" );
}

void TelegramApi::onAccountResetAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::resetAuthorizationResult(&inboundPkt);
    Q_EMIT accountResetAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountResetAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountResetAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetPassword(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getPassword(&p);
    return session->sendQuery(p, &accountGetPasswordMethods, attachedData, "Account->getPassword" );
}

void TelegramApi::onAccountGetPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPassword &result = Functions::Account::getPasswordResult(&inboundPkt);
    if(result.error())
        onAccountGetPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetPasswordSettings(const QByteArray &current_password_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getPasswordSettings(&p, current_password_hash);
    return session->sendQuery(p, &accountGetPasswordSettingsMethods, attachedData, "Account->getPasswordSettings" );
}

void TelegramApi::onAccountGetPasswordSettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPasswordSettings &result = Functions::Account::getPasswordSettingsResult(&inboundPkt);
    if(result.error())
        onAccountGetPasswordSettingsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetPasswordSettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetPasswordSettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetPasswordSettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdatePasswordSettings(const QByteArray &current_password_hash, const AccountPasswordInputSettings &new_settings, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updatePasswordSettings(&p, current_password_hash, new_settings);
    return session->sendQuery(p, &accountUpdatePasswordSettingsMethods, attachedData, "Account->updatePasswordSettings" );
}

void TelegramApi::onAccountUpdatePasswordSettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updatePasswordSettingsResult(&inboundPkt);
    Q_EMIT accountUpdatePasswordSettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdatePasswordSettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdatePasswordSettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSendConfirmPhoneCode(bool allow_flashcall, const QString &hash, bool current_number, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::sendConfirmPhoneCode(&p, allow_flashcall, hash, current_number);
    return session->sendQuery(p, &accountSendConfirmPhoneCodeMethods, attachedData, "Account->sendConfirmPhoneCode" );
}

void TelegramApi::onAccountSendConfirmPhoneCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthSentCode &result = Functions::Account::sendConfirmPhoneCodeResult(&inboundPkt);
    if(result.error())
        onAccountSendConfirmPhoneCodeError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountSendConfirmPhoneCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSendConfirmPhoneCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSendConfirmPhoneCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountConfirmPhone(const QString &phone_code_hash, const QString &phone_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::confirmPhone(&p, phone_code_hash, phone_code);
    return session->sendQuery(p, &accountConfirmPhoneMethods, attachedData, "Account->confirmPhone" );
}

void TelegramApi::onAccountConfirmPhoneAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::confirmPhoneResult(&inboundPkt);
    Q_EMIT accountConfirmPhoneAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountConfirmPhoneError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountConfirmPhoneError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetTmpPassword(const QByteArray &password_hash, qint32 period, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getTmpPassword(&p, password_hash, period);
    return session->sendQuery(p, &accountGetTmpPasswordMethods, attachedData, "Account->getTmpPassword" );
}

void TelegramApi::onAccountGetTmpPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountTmpPassword &result = Functions::Account::getTmpPasswordResult(&inboundPkt);
    if(result.error())
        onAccountGetTmpPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetTmpPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetTmpPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetTmpPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::authCheckPhone(const QString &phone_number, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::checkPhone(&p, phone_number);
    return session->sendQuery(p, &authCheckPhoneMethods, attachedData, "Auth->checkPhone" );
}

void TelegramApi::onAuthCheckPhoneAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthCheckedPhone &result = Functions::Auth::checkPhoneResult(&inboundPkt);
    if(result.error())
        onAuthCheckPhoneError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authCheckPhoneAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthCheckPhoneError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authCheckPhoneError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSendCode(bool allow_flashcall, const QString &phone_number, bool current_number, qint32 api_id, const QString &api_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::sendCode(&p, allow_flashcall, phone_number, current_number, api_id, api_hash);
    return session->sendQuery(p, &authSendCodeMethods, attachedData, "Auth->sendCode" );
}

void TelegramApi::onAuthSendCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthSentCode &result = Functions::Auth::sendCodeResult(&inboundPkt);
    if(result.error())
        onAuthSendCodeError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authSendCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSendCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSendCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSignUp(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QString &first_name, const QString &last_name, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::signUp(&p, phone_number, phone_code_hash, phone_code, first_name, last_name);
    return session->sendQuery(p, &authSignUpMethods, attachedData, "Auth->signUp" );
}

void TelegramApi::onAuthSignUpAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::signUpResult(&inboundPkt);
    if(result.error())
        onAuthSignUpError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authSignUpAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSignUpError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSignUpError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSignIn(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::signIn(&p, phone_number, phone_code_hash, phone_code);
    return session->sendQuery(p, &authSignInMethods, attachedData, "Auth->signIn" );
}

void TelegramApi::onAuthSignInAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::signInResult(&inboundPkt);
    if(result.error())
        onAuthSignInError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authSignInAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSignInError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSignInError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authLogOut(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::logOut(&p);
    return session->sendQuery(p, &authLogOutMethods, attachedData, "Auth->logOut" );
}

void TelegramApi::onAuthLogOutAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::logOutResult(&inboundPkt);
    Q_EMIT authLogOutAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthLogOutError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authLogOutError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authResetAuthorizations(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::resetAuthorizations(&p);
    return session->sendQuery(p, &authResetAuthorizationsMethods, attachedData, "Auth->resetAuthorizations" );
}

void TelegramApi::onAuthResetAuthorizationsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::resetAuthorizationsResult(&inboundPkt);
    Q_EMIT authResetAuthorizationsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthResetAuthorizationsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authResetAuthorizationsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSendInvites(const QList<QString> &phone_numbers, const QString &message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::sendInvites(&p, phone_numbers, message);
    return session->sendQuery(p, &authSendInvitesMethods, attachedData, "Auth->sendInvites" );
}

void TelegramApi::onAuthSendInvitesAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::sendInvitesResult(&inboundPkt);
    Q_EMIT authSendInvitesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSendInvitesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSendInvitesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authExportAuthorization(qint32 dc_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::exportAuthorization(&p, dc_id);
    return session->sendQuery(p, &authExportAuthorizationMethods, attachedData, "Auth->exportAuthorization" );
}

void TelegramApi::onAuthExportAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthExportedAuthorization &result = Functions::Auth::exportAuthorizationResult(&inboundPkt);
    if(result.error())
        onAuthExportAuthorizationError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authExportAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthExportAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authExportAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authImportAuthorization(qint32 id, const QByteArray &bytes, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::importAuthorization(&p, id, bytes);
    return session->sendQuery(p, &authImportAuthorizationMethods, attachedData, "Auth->importAuthorization" );
}

void TelegramApi::onAuthImportAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::importAuthorizationResult(&inboundPkt);
    if(result.error())
        onAuthImportAuthorizationError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authImportAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthImportAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authImportAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authBindTempAuthKey(qint64 perm_auth_key_id, qint64 nonce, qint32 expires_at, const QByteArray &encrypted_message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::bindTempAuthKey(&p, perm_auth_key_id, nonce, expires_at, encrypted_message);
    return session->sendQuery(p, &authBindTempAuthKeyMethods, attachedData, "Auth->bindTempAuthKey" );
}

void TelegramApi::onAuthBindTempAuthKeyAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::bindTempAuthKeyResult(&inboundPkt);
    Q_EMIT authBindTempAuthKeyAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthBindTempAuthKeyError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authBindTempAuthKeyError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authImportBotAuthorization(qint32 flags, qint32 api_id, const QString &api_hash, const QString &bot_auth_token, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::importBotAuthorization(&p, flags, api_id, api_hash, bot_auth_token);
    return session->sendQuery(p, &authImportBotAuthorizationMethods, attachedData, "Auth->importBotAuthorization" );
}

void TelegramApi::onAuthImportBotAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::importBotAuthorizationResult(&inboundPkt);
    if(result.error())
        onAuthImportBotAuthorizationError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authImportBotAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthImportBotAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authImportBotAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authCheckPassword(const QByteArray &password_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::checkPassword(&p, password_hash);
    return session->sendQuery(p, &authCheckPasswordMethods, attachedData, "Auth->checkPassword" );
}

void TelegramApi::onAuthCheckPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::checkPasswordResult(&inboundPkt);
    if(result.error())
        onAuthCheckPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authCheckPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthCheckPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authCheckPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authRequestPasswordRecovery(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::requestPasswordRecovery(&p);
    return session->sendQuery(p, &authRequestPasswordRecoveryMethods, attachedData, "Auth->requestPasswordRecovery" );
}

void TelegramApi::onAuthRequestPasswordRecoveryAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthPasswordRecovery &result = Functions::Auth::requestPasswordRecoveryResult(&inboundPkt);
    if(result.error())
        onAuthRequestPasswordRecoveryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authRequestPasswordRecoveryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthRequestPasswordRecoveryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authRequestPasswordRecoveryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authRecoverPassword(const QString &code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::recoverPassword(&p, code);
    return session->sendQuery(p, &authRecoverPasswordMethods, attachedData, "Auth->recoverPassword" );
}

void TelegramApi::onAuthRecoverPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::recoverPasswordResult(&inboundPkt);
    if(result.error())
        onAuthRecoverPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authRecoverPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthRecoverPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authRecoverPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authResendCode(const QString &phone_number, const QString &phone_code_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::resendCode(&p, phone_number, phone_code_hash);
    return session->sendQuery(p, &authResendCodeMethods, attachedData, "Auth->resendCode" );
}

void TelegramApi::onAuthResendCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthSentCode &result = Functions::Auth::resendCodeResult(&inboundPkt);
    if(result.error())
        onAuthResendCodeError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authResendCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthResendCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authResendCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authCancelCode(const QString &phone_number, const QString &phone_code_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::cancelCode(&p, phone_number, phone_code_hash);
    return session->sendQuery(p, &authCancelCodeMethods, attachedData, "Auth->cancelCode" );
}

void TelegramApi::onAuthCancelCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::cancelCodeResult(&inboundPkt);
    Q_EMIT authCancelCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthCancelCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authCancelCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authDropTempAuthKeys(const QList<qint64> &except_auth_keys, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::dropTempAuthKeys(&p, except_auth_keys);
    return session->sendQuery(p, &authDropTempAuthKeysMethods, attachedData, "Auth->dropTempAuthKeys" );
}

void TelegramApi::onAuthDropTempAuthKeysAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::dropTempAuthKeysResult(&inboundPkt);
    Q_EMIT authDropTempAuthKeysAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthDropTempAuthKeysError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authDropTempAuthKeysError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::botsSendCustomRequest(const QString &custom_method, const DataJSON &params, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Bots::sendCustomRequest(&p, custom_method, params);
    return session->sendQuery(p, &botsSendCustomRequestMethods, attachedData, "Bots->sendCustomRequest" );
}

void TelegramApi::onBotsSendCustomRequestAnswer(Query *q, InboundPkt &inboundPkt) {
    const DataJSON &result = Functions::Bots::sendCustomRequestResult(&inboundPkt);
    if(result.error())
        onBotsSendCustomRequestError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT botsSendCustomRequestAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onBotsSendCustomRequestError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT botsSendCustomRequestError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::botsAnswerWebhookJSONQuery(qint64 query_id, const DataJSON &data, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Bots::answerWebhookJSONQuery(&p, query_id, data);
    return session->sendQuery(p, &botsAnswerWebhookJSONQueryMethods, attachedData, "Bots->answerWebhookJSONQuery" );
}

void TelegramApi::onBotsAnswerWebhookJSONQueryAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Bots::answerWebhookJSONQueryResult(&inboundPkt);
    Q_EMIT botsAnswerWebhookJSONQueryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onBotsAnswerWebhookJSONQueryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT botsAnswerWebhookJSONQueryError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::channelsReadHistory(const InputChannel &channel, qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::readHistory(&p, channel, max_id);
    return session->sendQuery(p, &channelsReadHistoryMethods, attachedData, "Channels->readHistory" );
}

void TelegramApi::onChannelsReadHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::readHistoryResult(&inboundPkt);
    Q_EMIT channelsReadHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsReadHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsReadHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsDeleteMessages(const InputChannel &channel, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::deleteMessages(&p, channel, id);
    return session->sendQuery(p, &channelsDeleteMessagesMethods, attachedData, "Channels->deleteMessages" );
}

void TelegramApi::onChannelsDeleteMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Channels::deleteMessagesResult(&inboundPkt);
    if(result.error())
        onChannelsDeleteMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsDeleteMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsDeleteMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsDeleteMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsDeleteUserHistory(const InputChannel &channel, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::deleteUserHistory(&p, channel, user_id);
    return session->sendQuery(p, &channelsDeleteUserHistoryMethods, attachedData, "Channels->deleteUserHistory" );
}

void TelegramApi::onChannelsDeleteUserHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedHistory &result = Functions::Channels::deleteUserHistoryResult(&inboundPkt);
    if(result.error())
        onChannelsDeleteUserHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsDeleteUserHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsDeleteUserHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsDeleteUserHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsReportSpam(const InputChannel &channel, const InputUser &user_id, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::reportSpam(&p, channel, user_id, id);
    return session->sendQuery(p, &channelsReportSpamMethods, attachedData, "Channels->reportSpam" );
}

void TelegramApi::onChannelsReportSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::reportSpamResult(&inboundPkt);
    Q_EMIT channelsReportSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsReportSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsReportSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetMessages(const InputChannel &channel, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getMessages(&p, channel, id);
    return session->sendQuery(p, &channelsGetMessagesMethods, attachedData, "Channels->getMessages" );
}

void TelegramApi::onChannelsGetMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Channels::getMessagesResult(&inboundPkt);
    if(result.error())
        onChannelsGetMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetParticipants(const InputChannel &channel, const ChannelParticipantsFilter &filter, qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getParticipants(&p, channel, filter, offset, limit);
    return session->sendQuery(p, &channelsGetParticipantsMethods, attachedData, "Channels->getParticipants" );
}

void TelegramApi::onChannelsGetParticipantsAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChannelsChannelParticipants &result = Functions::Channels::getParticipantsResult(&inboundPkt);
    if(result.error())
        onChannelsGetParticipantsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetParticipantsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetParticipantsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetParticipantsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetParticipant(const InputChannel &channel, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getParticipant(&p, channel, user_id);
    return session->sendQuery(p, &channelsGetParticipantMethods, attachedData, "Channels->getParticipant" );
}

void TelegramApi::onChannelsGetParticipantAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChannelsChannelParticipant &result = Functions::Channels::getParticipantResult(&inboundPkt);
    if(result.error())
        onChannelsGetParticipantError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetParticipantAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetParticipantError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetParticipantError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetChannels(const QList<InputChannel> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getChannels(&p, id);
    return session->sendQuery(p, &channelsGetChannelsMethods, attachedData, "Channels->getChannels" );
}

void TelegramApi::onChannelsGetChannelsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Channels::getChannelsResult(&inboundPkt);
    if(result.error())
        onChannelsGetChannelsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetChannelsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetChannelsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetChannelsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetFullChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getFullChannel(&p, channel);
    return session->sendQuery(p, &channelsGetFullChannelMethods, attachedData, "Channels->getFullChannel" );
}

void TelegramApi::onChannelsGetFullChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChatFull &result = Functions::Channels::getFullChannelResult(&inboundPkt);
    if(result.error())
        onChannelsGetFullChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetFullChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetFullChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetFullChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsCreateChannel(bool broadcast, bool megagroup, const QString &title, const QString &about, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::createChannel(&p, broadcast, megagroup, title, about);
    return session->sendQuery(p, &channelsCreateChannelMethods, attachedData, "Channels->createChannel" );
}

void TelegramApi::onChannelsCreateChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::createChannelResult(&inboundPkt);
    if(result.error())
        onChannelsCreateChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsCreateChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsCreateChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsCreateChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditAbout(const InputChannel &channel, const QString &about, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editAbout(&p, channel, about);
    return session->sendQuery(p, &channelsEditAboutMethods, attachedData, "Channels->editAbout" );
}

void TelegramApi::onChannelsEditAboutAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::editAboutResult(&inboundPkt);
    Q_EMIT channelsEditAboutAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditAboutError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditAboutError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditAdmin(const InputChannel &channel, const InputUser &user_id, const ChannelAdminRights &admin_rights, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editAdmin(&p, channel, user_id, admin_rights);
    return session->sendQuery(p, &channelsEditAdminMethods, attachedData, "Channels->editAdmin" );
}

void TelegramApi::onChannelsEditAdminAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editAdminResult(&inboundPkt);
    if(result.error())
        onChannelsEditAdminError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditAdminAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditAdminError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditAdminError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditTitle(const InputChannel &channel, const QString &title, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editTitle(&p, channel, title);
    return session->sendQuery(p, &channelsEditTitleMethods, attachedData, "Channels->editTitle" );
}

void TelegramApi::onChannelsEditTitleAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editTitleResult(&inboundPkt);
    if(result.error())
        onChannelsEditTitleError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditTitleAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditTitleError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditTitleError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditPhoto(const InputChannel &channel, const InputChatPhoto &photo, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editPhoto(&p, channel, photo);
    return session->sendQuery(p, &channelsEditPhotoMethods, attachedData, "Channels->editPhoto" );
}

void TelegramApi::onChannelsEditPhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editPhotoResult(&inboundPkt);
    if(result.error())
        onChannelsEditPhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditPhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditPhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditPhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsCheckUsername(const InputChannel &channel, const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::checkUsername(&p, channel, username);
    return session->sendQuery(p, &channelsCheckUsernameMethods, attachedData, "Channels->checkUsername" );
}

void TelegramApi::onChannelsCheckUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::checkUsernameResult(&inboundPkt);
    Q_EMIT channelsCheckUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsCheckUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsCheckUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsUpdateUsername(const InputChannel &channel, const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::updateUsername(&p, channel, username);
    return session->sendQuery(p, &channelsUpdateUsernameMethods, attachedData, "Channels->updateUsername" );
}

void TelegramApi::onChannelsUpdateUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::updateUsernameResult(&inboundPkt);
    Q_EMIT channelsUpdateUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsUpdateUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsUpdateUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsJoinChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::joinChannel(&p, channel);
    return session->sendQuery(p, &channelsJoinChannelMethods, attachedData, "Channels->joinChannel" );
}

void TelegramApi::onChannelsJoinChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::joinChannelResult(&inboundPkt);
    if(result.error())
        onChannelsJoinChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsJoinChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsJoinChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsJoinChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsLeaveChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::leaveChannel(&p, channel);
    return session->sendQuery(p, &channelsLeaveChannelMethods, attachedData, "Channels->leaveChannel" );
}

void TelegramApi::onChannelsLeaveChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::leaveChannelResult(&inboundPkt);
    if(result.error())
        onChannelsLeaveChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsLeaveChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsLeaveChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsLeaveChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsInviteToChannel(const InputChannel &channel, const QList<InputUser> &users, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::inviteToChannel(&p, channel, users);
    return session->sendQuery(p, &channelsInviteToChannelMethods, attachedData, "Channels->inviteToChannel" );
}

void TelegramApi::onChannelsInviteToChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::inviteToChannelResult(&inboundPkt);
    if(result.error())
        onChannelsInviteToChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsInviteToChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsInviteToChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsInviteToChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsExportInvite(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::exportInvite(&p, channel);
    return session->sendQuery(p, &channelsExportInviteMethods, attachedData, "Channels->exportInvite" );
}

void TelegramApi::onChannelsExportInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const ExportedChatInvite &result = Functions::Channels::exportInviteResult(&inboundPkt);
    if(result.error())
        onChannelsExportInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsExportInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsExportInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsExportInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsDeleteChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::deleteChannel(&p, channel);
    return session->sendQuery(p, &channelsDeleteChannelMethods, attachedData, "Channels->deleteChannel" );
}

void TelegramApi::onChannelsDeleteChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::deleteChannelResult(&inboundPkt);
    if(result.error())
        onChannelsDeleteChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsDeleteChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsDeleteChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsDeleteChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsToggleInvites(const InputChannel &channel, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::toggleInvites(&p, channel, enabled);
    return session->sendQuery(p, &channelsToggleInvitesMethods, attachedData, "Channels->toggleInvites" );
}

void TelegramApi::onChannelsToggleInvitesAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::toggleInvitesResult(&inboundPkt);
    if(result.error())
        onChannelsToggleInvitesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsToggleInvitesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsToggleInvitesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsToggleInvitesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsExportMessageLink(const InputChannel &channel, qint32 id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::exportMessageLink(&p, channel, id);
    return session->sendQuery(p, &channelsExportMessageLinkMethods, attachedData, "Channels->exportMessageLink" );
}

void TelegramApi::onChannelsExportMessageLinkAnswer(Query *q, InboundPkt &inboundPkt) {
    const ExportedMessageLink &result = Functions::Channels::exportMessageLinkResult(&inboundPkt);
    if(result.error())
        onChannelsExportMessageLinkError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsExportMessageLinkAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsExportMessageLinkError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsExportMessageLinkError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsToggleSignatures(const InputChannel &channel, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::toggleSignatures(&p, channel, enabled);
    return session->sendQuery(p, &channelsToggleSignaturesMethods, attachedData, "Channels->toggleSignatures" );
}

void TelegramApi::onChannelsToggleSignaturesAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::toggleSignaturesResult(&inboundPkt);
    if(result.error())
        onChannelsToggleSignaturesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsToggleSignaturesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsToggleSignaturesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsToggleSignaturesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsUpdatePinnedMessage(bool silent, const InputChannel &channel, qint32 id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::updatePinnedMessage(&p, silent, channel, id);
    return session->sendQuery(p, &channelsUpdatePinnedMessageMethods, attachedData, "Channels->updatePinnedMessage" );
}

void TelegramApi::onChannelsUpdatePinnedMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::updatePinnedMessageResult(&inboundPkt);
    if(result.error())
        onChannelsUpdatePinnedMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsUpdatePinnedMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsUpdatePinnedMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsUpdatePinnedMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetAdminedPublicChannels(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getAdminedPublicChannels(&p);
    return session->sendQuery(p, &channelsGetAdminedPublicChannelsMethods, attachedData, "Channels->getAdminedPublicChannels" );
}

void TelegramApi::onChannelsGetAdminedPublicChannelsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Channels::getAdminedPublicChannelsResult(&inboundPkt);
    if(result.error())
        onChannelsGetAdminedPublicChannelsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetAdminedPublicChannelsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetAdminedPublicChannelsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetAdminedPublicChannelsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditBanned(const InputChannel &channel, const InputUser &user_id, const ChannelBannedRights &banned_rights, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editBanned(&p, channel, user_id, banned_rights);
    return session->sendQuery(p, &channelsEditBannedMethods, attachedData, "Channels->editBanned" );
}

void TelegramApi::onChannelsEditBannedAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editBannedResult(&inboundPkt);
    if(result.error())
        onChannelsEditBannedError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditBannedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditBannedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditBannedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetAdminLog(const InputChannel &channel, const QString &q, const ChannelAdminLogEventsFilter &events_filter, const QList<InputUser> &admins, qint64 max_id, qint64 min_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getAdminLog(&p, channel, q, events_filter, admins, max_id, min_id, limit);
    return session->sendQuery(p, &channelsGetAdminLogMethods, attachedData, "Channels->getAdminLog" );
}

void TelegramApi::onChannelsGetAdminLogAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChannelsAdminLogResults &result = Functions::Channels::getAdminLogResult(&inboundPkt);
    if(result.error())
        onChannelsGetAdminLogError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetAdminLogAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetAdminLogError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetAdminLogError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::contactsGetStatuses(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getStatuses(&p);
    return session->sendQuery(p, &contactsGetStatusesMethods, attachedData, "Contacts->getStatuses" );
}

void TelegramApi::onContactsGetStatusesAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<ContactStatus> &result = Functions::Contacts::getStatusesResult(&inboundPkt);
    Q_EMIT contactsGetStatusesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetStatusesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetStatusesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsGetContacts(const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getContacts(&p, hash);
    return session->sendQuery(p, &contactsGetContactsMethods, attachedData, "Contacts->getContacts" );
}

void TelegramApi::onContactsGetContactsAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsContacts &result = Functions::Contacts::getContactsResult(&inboundPkt);
    if(result.error())
        onContactsGetContactsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsGetContactsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetContactsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetContactsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsImportContacts(const QList<InputContact> &contacts, bool replace, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::importContacts(&p, contacts, replace);
    return session->sendQuery(p, &contactsImportContactsMethods, attachedData, "Contacts->importContacts" );
}

void TelegramApi::onContactsImportContactsAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsImportedContacts &result = Functions::Contacts::importContactsResult(&inboundPkt);
    if(result.error())
        onContactsImportContactsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsImportContactsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsImportContactsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsImportContactsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsDeleteContact(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::deleteContact(&p, id);
    return session->sendQuery(p, &contactsDeleteContactMethods, attachedData, "Contacts->deleteContact" );
}

void TelegramApi::onContactsDeleteContactAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsLink &result = Functions::Contacts::deleteContactResult(&inboundPkt);
    if(result.error())
        onContactsDeleteContactError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsDeleteContactAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsDeleteContactError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsDeleteContactError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsDeleteContacts(const QList<InputUser> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::deleteContacts(&p, id);
    return session->sendQuery(p, &contactsDeleteContactsMethods, attachedData, "Contacts->deleteContacts" );
}

void TelegramApi::onContactsDeleteContactsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::deleteContactsResult(&inboundPkt);
    Q_EMIT contactsDeleteContactsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsDeleteContactsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsDeleteContactsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsBlock(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::block(&p, id);
    return session->sendQuery(p, &contactsBlockMethods, attachedData, "Contacts->block" );
}

void TelegramApi::onContactsBlockAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::blockResult(&inboundPkt);
    Q_EMIT contactsBlockAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsBlockError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsBlockError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsUnblock(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::unblock(&p, id);
    return session->sendQuery(p, &contactsUnblockMethods, attachedData, "Contacts->unblock" );
}

void TelegramApi::onContactsUnblockAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::unblockResult(&inboundPkt);
    Q_EMIT contactsUnblockAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsUnblockError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsUnblockError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsGetBlocked(qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getBlocked(&p, offset, limit);
    return session->sendQuery(p, &contactsGetBlockedMethods, attachedData, "Contacts->getBlocked" );
}

void TelegramApi::onContactsGetBlockedAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsBlocked &result = Functions::Contacts::getBlockedResult(&inboundPkt);
    if(result.error())
        onContactsGetBlockedError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsGetBlockedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetBlockedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetBlockedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsExportCard(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::exportCard(&p);
    return session->sendQuery(p, &contactsExportCardMethods, attachedData, "Contacts->exportCard" );
}

void TelegramApi::onContactsExportCardAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint32> &result = Functions::Contacts::exportCardResult(&inboundPkt);
    Q_EMIT contactsExportCardAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsExportCardError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsExportCardError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsImportCard(const QList<qint32> &export_card, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::importCard(&p, export_card);
    return session->sendQuery(p, &contactsImportCardMethods, attachedData, "Contacts->importCard" );
}

void TelegramApi::onContactsImportCardAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Contacts::importCardResult(&inboundPkt);
    if(result.error())
        onContactsImportCardError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsImportCardAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsImportCardError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsImportCardError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsSearch(const QString &q, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::search(&p, q, limit);
    return session->sendQuery(p, &contactsSearchMethods, attachedData, "Contacts->search" );
}

void TelegramApi::onContactsSearchAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsFound &result = Functions::Contacts::searchResult(&inboundPkt);
    if(result.error())
        onContactsSearchError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsSearchAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsSearchError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsSearchError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsResolveUsername(const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::resolveUsername(&p, username);
    return session->sendQuery(p, &contactsResolveUsernameMethods, attachedData, "Contacts->resolveUsername" );
}

void TelegramApi::onContactsResolveUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsResolvedPeer &result = Functions::Contacts::resolveUsernameResult(&inboundPkt);
    if(result.error())
        onContactsResolveUsernameError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsResolveUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsResolveUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsResolveUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsGetTopPeers(bool correspondents, bool bots_pm, bool bots_inline, bool phone_calls, bool groups, bool channels, qint32 offset, qint32 limit, qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getTopPeers(&p, correspondents, bots_pm, bots_inline, phone_calls, groups, channels, offset, limit, hash);
    return session->sendQuery(p, &contactsGetTopPeersMethods, attachedData, "Contacts->getTopPeers" );
}

void TelegramApi::onContactsGetTopPeersAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsTopPeers &result = Functions::Contacts::getTopPeersResult(&inboundPkt);
    if(result.error())
        onContactsGetTopPeersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsGetTopPeersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetTopPeersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetTopPeersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsResetTopPeerRating(const TopPeerCategory &category, const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::resetTopPeerRating(&p, category, peer);
    return session->sendQuery(p, &contactsResetTopPeerRatingMethods, attachedData, "Contacts->resetTopPeerRating" );
}

void TelegramApi::onContactsResetTopPeerRatingAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::resetTopPeerRatingResult(&inboundPkt);
    Q_EMIT contactsResetTopPeerRatingAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsResetTopPeerRatingError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsResetTopPeerRatingError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::helpGetConfig(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getConfig(&p);
    return session->sendQuery(p, &helpGetConfigMethods, attachedData, "Help->getConfig" );
}

void TelegramApi::onHelpGetConfigAnswer(Query *q, InboundPkt &inboundPkt) {
    const Config &result = Functions::Help::getConfigResult(&inboundPkt);
    if(result.error())
        onHelpGetConfigError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetConfigAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetConfigError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetConfigError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetNearestDc(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getNearestDc(&p);
    return session->sendQuery(p, &helpGetNearestDcMethods, attachedData, "Help->getNearestDc" );
}

void TelegramApi::onHelpGetNearestDcAnswer(Query *q, InboundPkt &inboundPkt) {
    const NearestDc &result = Functions::Help::getNearestDcResult(&inboundPkt);
    if(result.error())
        onHelpGetNearestDcError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetNearestDcAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetNearestDcError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetNearestDcError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetAppUpdate(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getAppUpdate(&p);
    return session->sendQuery(p, &helpGetAppUpdateMethods, attachedData, "Help->getAppUpdate" );
}

void TelegramApi::onHelpGetAppUpdateAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpAppUpdate &result = Functions::Help::getAppUpdateResult(&inboundPkt);
    if(result.error())
        onHelpGetAppUpdateError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetAppUpdateAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetAppUpdateError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetAppUpdateError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpSaveAppLog(const QList<InputAppEvent> &events, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::saveAppLog(&p, events);
    return session->sendQuery(p, &helpSaveAppLogMethods, attachedData, "Help->saveAppLog" );
}

void TelegramApi::onHelpSaveAppLogAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Help::saveAppLogResult(&inboundPkt);
    Q_EMIT helpSaveAppLogAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpSaveAppLogError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpSaveAppLogError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetInviteText(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getInviteText(&p);
    return session->sendQuery(p, &helpGetInviteTextMethods, attachedData, "Help->getInviteText" );
}

void TelegramApi::onHelpGetInviteTextAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpInviteText &result = Functions::Help::getInviteTextResult(&inboundPkt);
    if(result.error())
        onHelpGetInviteTextError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetInviteTextAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetInviteTextError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetInviteTextError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetSupport(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getSupport(&p);
    return session->sendQuery(p, &helpGetSupportMethods, attachedData, "Help->getSupport" );
}

void TelegramApi::onHelpGetSupportAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpSupport &result = Functions::Help::getSupportResult(&inboundPkt);
    if(result.error())
        onHelpGetSupportError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetSupportAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetSupportError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetSupportError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetAppChangelog(const QString &prev_app_version, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getAppChangelog(&p, prev_app_version);
    return session->sendQuery(p, &helpGetAppChangelogMethods, attachedData, "Help->getAppChangelog" );
}

void TelegramApi::onHelpGetAppChangelogAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Help::getAppChangelogResult(&inboundPkt);
    if(result.error())
        onHelpGetAppChangelogError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetAppChangelogAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetAppChangelogError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetAppChangelogError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetTermsOfService(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getTermsOfService(&p);
    return session->sendQuery(p, &helpGetTermsOfServiceMethods, attachedData, "Help->getTermsOfService" );
}

void TelegramApi::onHelpGetTermsOfServiceAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpTermsOfService &result = Functions::Help::getTermsOfServiceResult(&inboundPkt);
    if(result.error())
        onHelpGetTermsOfServiceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetTermsOfServiceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetTermsOfServiceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetTermsOfServiceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpSetBotUpdatesStatus(qint32 pending_updates_count, const QString &message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::setBotUpdatesStatus(&p, pending_updates_count, message);
    return session->sendQuery(p, &helpSetBotUpdatesStatusMethods, attachedData, "Help->setBotUpdatesStatus" );
}

void TelegramApi::onHelpSetBotUpdatesStatusAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Help::setBotUpdatesStatusResult(&inboundPkt);
    Q_EMIT helpSetBotUpdatesStatusAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpSetBotUpdatesStatusError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpSetBotUpdatesStatusError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetCdnConfig(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getCdnConfig(&p);
    return session->sendQuery(p, &helpGetCdnConfigMethods, attachedData, "Help->getCdnConfig" );
}

void TelegramApi::onHelpGetCdnConfigAnswer(Query *q, InboundPkt &inboundPkt) {
    const CdnConfig &result = Functions::Help::getCdnConfigResult(&inboundPkt);
    if(result.error())
        onHelpGetCdnConfigError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetCdnConfigAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetCdnConfigError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetCdnConfigError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::langpackGetLangPack(const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Langpack::getLangPack(&p, lang_code);
    return session->sendQuery(p, &langpackGetLangPackMethods, attachedData, "Langpack->getLangPack" );
}

void TelegramApi::onLangpackGetLangPackAnswer(Query *q, InboundPkt &inboundPkt) {
    const LangPackDifference &result = Functions::Langpack::getLangPackResult(&inboundPkt);
    if(result.error())
        onLangpackGetLangPackError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT langpackGetLangPackAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onLangpackGetLangPackError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT langpackGetLangPackError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::langpackGetStrings(const QString &lang_code, const QList<QString> &keys, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Langpack::getStrings(&p, lang_code, keys);
    return session->sendQuery(p, &langpackGetStringsMethods, attachedData, "Langpack->getStrings" );
}

void TelegramApi::onLangpackGetStringsAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<LangPackString> &result = Functions::Langpack::getStringsResult(&inboundPkt);
    Q_EMIT langpackGetStringsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onLangpackGetStringsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT langpackGetStringsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::langpackGetDifference(qint32 from_version, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Langpack::getDifference(&p, from_version);
    return session->sendQuery(p, &langpackGetDifferenceMethods, attachedData, "Langpack->getDifference" );
}

void TelegramApi::onLangpackGetDifferenceAnswer(Query *q, InboundPkt &inboundPkt) {
    const LangPackDifference &result = Functions::Langpack::getDifferenceResult(&inboundPkt);
    if(result.error())
        onLangpackGetDifferenceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT langpackGetDifferenceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onLangpackGetDifferenceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT langpackGetDifferenceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::langpackGetLanguages(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Langpack::getLanguages(&p);
    return session->sendQuery(p, &langpackGetLanguagesMethods, attachedData, "Langpack->getLanguages" );
}

void TelegramApi::onLangpackGetLanguagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<LangPackLanguage> &result = Functions::Langpack::getLanguagesResult(&inboundPkt);
    Q_EMIT langpackGetLanguagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onLangpackGetLanguagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT langpackGetLanguagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::messagesGetMessages(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getMessages(&p, id);
    return session->sendQuery(p, &messagesGetMessagesMethods, attachedData, "Messages->getMessages" );
}

void TelegramApi::onMessagesGetMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::getMessagesResult(&inboundPkt);
    if(result.error())
        onMessagesGetMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetDialogs(bool exclude_pinned, qint32 offset_date, qint32 offset_id, const InputPeer &offset_peer, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getDialogs(&p, exclude_pinned, offset_date, offset_id, offset_peer, limit);
    return session->sendQuery(p, &messagesGetDialogsMethods, attachedData, "Messages->getDialogs" );
}

void TelegramApi::onMessagesGetDialogsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesDialogs &result = Functions::Messages::getDialogsResult(&inboundPkt);
    if(result.error())
        onMessagesGetDialogsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetDialogsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetDialogsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetDialogsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetHistory(const InputPeer &peer, qint32 offset_id, qint32 offset_date, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getHistory(&p, peer, offset_id, offset_date, add_offset, limit, max_id, min_id);
    return session->sendQuery(p, &messagesGetHistoryMethods, attachedData, "Messages->getHistory" );
}

void TelegramApi::onMessagesGetHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::getHistoryResult(&inboundPkt);
    if(result.error())
        onMessagesGetHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSearch(const InputPeer &peer, const QString &q, const InputUser &from_id, const MessagesFilter &filter, qint32 min_date, qint32 max_date, qint32 offset, qint32 max_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::search(&p, peer, q, from_id, filter, min_date, max_date, offset, max_id, limit);
    return session->sendQuery(p, &messagesSearchMethods, attachedData, "Messages->search" );
}

void TelegramApi::onMessagesSearchAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::searchResult(&inboundPkt);
    if(result.error())
        onMessagesSearchError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSearchAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSearchError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSearchError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadHistory(const InputPeer &peer, qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readHistory(&p, peer, max_id);
    return session->sendQuery(p, &messagesReadHistoryMethods, attachedData, "Messages->readHistory" );
}

void TelegramApi::onMessagesReadHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Messages::readHistoryResult(&inboundPkt);
    if(result.error())
        onMessagesReadHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesReadHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDeleteHistory(bool just_clear, const InputPeer &peer, qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::deleteHistory(&p, just_clear, peer, max_id);
    return session->sendQuery(p, &messagesDeleteHistoryMethods, attachedData, "Messages->deleteHistory" );
}

void TelegramApi::onMessagesDeleteHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedHistory &result = Functions::Messages::deleteHistoryResult(&inboundPkt);
    if(result.error())
        onMessagesDeleteHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesDeleteHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDeleteHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDeleteHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDeleteMessages(bool revoke, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::deleteMessages(&p, revoke, id);
    return session->sendQuery(p, &messagesDeleteMessagesMethods, attachedData, "Messages->deleteMessages" );
}

void TelegramApi::onMessagesDeleteMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Messages::deleteMessagesResult(&inboundPkt);
    if(result.error())
        onMessagesDeleteMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesDeleteMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDeleteMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDeleteMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReceivedMessages(qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::receivedMessages(&p, max_id);
    return session->sendQuery(p, &messagesReceivedMessagesMethods, attachedData, "Messages->receivedMessages" );
}

void TelegramApi::onMessagesReceivedMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<ReceivedNotifyMessage> &result = Functions::Messages::receivedMessagesResult(&inboundPkt);
    Q_EMIT messagesReceivedMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReceivedMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReceivedMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetTyping(const InputPeer &peer, const SendMessageAction &action, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setTyping(&p, peer, action);
    return session->sendQuery(p, &messagesSetTypingMethods, attachedData, "Messages->setTyping" );
}

void TelegramApi::onMessagesSetTypingAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setTypingResult(&inboundPkt);
    Q_EMIT messagesSetTypingAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetTypingError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetTypingError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendMessage(bool no_webpage, bool silent, bool background, bool clear_draft, const InputPeer &peer, qint32 reply_to_msg_id, const QString &message, qint64 random_id, const ReplyMarkup &reply_markup, const QList<MessageEntity> &entities, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendMessage(&p, no_webpage, silent, background, clear_draft, peer, reply_to_msg_id, message, random_id, reply_markup, entities);
    return session->sendQuery(p, &messagesSendMessageMethods, attachedData, "Messages->sendMessage" );
}

void TelegramApi::onMessagesSendMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendMessageResult(&inboundPkt);
    if(result.error())
        onMessagesSendMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendMedia(bool silent, bool background, bool clear_draft, const InputPeer &peer, qint32 reply_to_msg_id, const InputMedia &media, qint64 random_id, const ReplyMarkup &reply_markup, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendMedia(&p, silent, background, clear_draft, peer, reply_to_msg_id, media, random_id, reply_markup);
    return session->sendQuery(p, &messagesSendMediaMethods, attachedData, "Messages->sendMedia" );
}

void TelegramApi::onMessagesSendMediaAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendMediaResult(&inboundPkt);
    if(result.error())
        onMessagesSendMediaError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendMediaAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendMediaError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendMediaError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesForwardMessages(bool silent, bool background, bool with_my_score, const InputPeer &from_peer, const QList<qint32> &id, const QList<qint64> &random_id, const InputPeer &to_peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::forwardMessages(&p, silent, background, with_my_score, from_peer, id, random_id, to_peer);
    return session->sendQuery(p, &messagesForwardMessagesMethods, attachedData, "Messages->forwardMessages" );
}

void TelegramApi::onMessagesForwardMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::forwardMessagesResult(&inboundPkt);
    if(result.error())
        onMessagesForwardMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesForwardMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesForwardMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesForwardMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReportSpam(const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::reportSpam(&p, peer);
    return session->sendQuery(p, &messagesReportSpamMethods, attachedData, "Messages->reportSpam" );
}

void TelegramApi::onMessagesReportSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::reportSpamResult(&inboundPkt);
    Q_EMIT messagesReportSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReportSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReportSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesHideReportSpam(const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::hideReportSpam(&p, peer);
    return session->sendQuery(p, &messagesHideReportSpamMethods, attachedData, "Messages->hideReportSpam" );
}

void TelegramApi::onMessagesHideReportSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::hideReportSpamResult(&inboundPkt);
    Q_EMIT messagesHideReportSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesHideReportSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesHideReportSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetPeerSettings(const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getPeerSettings(&p, peer);
    return session->sendQuery(p, &messagesGetPeerSettingsMethods, attachedData, "Messages->getPeerSettings" );
}

void TelegramApi::onMessagesGetPeerSettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const PeerSettings &result = Functions::Messages::getPeerSettingsResult(&inboundPkt);
    if(result.error())
        onMessagesGetPeerSettingsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetPeerSettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetPeerSettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetPeerSettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetChats(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getChats(&p, id);
    return session->sendQuery(p, &messagesGetChatsMethods, attachedData, "Messages->getChats" );
}

void TelegramApi::onMessagesGetChatsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Messages::getChatsResult(&inboundPkt);
    if(result.error())
        onMessagesGetChatsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetChatsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetChatsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetChatsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetFullChat(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getFullChat(&p, chat_id);
    return session->sendQuery(p, &messagesGetFullChatMethods, attachedData, "Messages->getFullChat" );
}

void TelegramApi::onMessagesGetFullChatAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChatFull &result = Functions::Messages::getFullChatResult(&inboundPkt);
    if(result.error())
        onMessagesGetFullChatError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetFullChatAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetFullChatError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetFullChatError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditChatTitle(qint32 chat_id, const QString &title, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editChatTitle(&p, chat_id, title);
    return session->sendQuery(p, &messagesEditChatTitleMethods, attachedData, "Messages->editChatTitle" );
}

void TelegramApi::onMessagesEditChatTitleAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::editChatTitleResult(&inboundPkt);
    if(result.error())
        onMessagesEditChatTitleError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesEditChatTitleAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditChatTitleError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditChatTitleError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditChatPhoto(qint32 chat_id, const InputChatPhoto &photo, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editChatPhoto(&p, chat_id, photo);
    return session->sendQuery(p, &messagesEditChatPhotoMethods, attachedData, "Messages->editChatPhoto" );
}

void TelegramApi::onMessagesEditChatPhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::editChatPhotoResult(&inboundPkt);
    if(result.error())
        onMessagesEditChatPhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesEditChatPhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditChatPhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditChatPhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesAddChatUser(qint32 chat_id, const InputUser &user_id, qint32 fwd_limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::addChatUser(&p, chat_id, user_id, fwd_limit);
    return session->sendQuery(p, &messagesAddChatUserMethods, attachedData, "Messages->addChatUser" );
}

void TelegramApi::onMessagesAddChatUserAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::addChatUserResult(&inboundPkt);
    if(result.error())
        onMessagesAddChatUserError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesAddChatUserAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesAddChatUserError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesAddChatUserError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDeleteChatUser(qint32 chat_id, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::deleteChatUser(&p, chat_id, user_id);
    return session->sendQuery(p, &messagesDeleteChatUserMethods, attachedData, "Messages->deleteChatUser" );
}

void TelegramApi::onMessagesDeleteChatUserAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::deleteChatUserResult(&inboundPkt);
    if(result.error())
        onMessagesDeleteChatUserError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesDeleteChatUserAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDeleteChatUserError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDeleteChatUserError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesCreateChat(const QList<InputUser> &users, const QString &title, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::createChat(&p, users, title);
    return session->sendQuery(p, &messagesCreateChatMethods, attachedData, "Messages->createChat" );
}

void TelegramApi::onMessagesCreateChatAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::createChatResult(&inboundPkt);
    if(result.error())
        onMessagesCreateChatError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesCreateChatAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesCreateChatError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesCreateChatError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesForwardMessage(const InputPeer &peer, qint32 id, qint64 random_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::forwardMessage(&p, peer, id, random_id);
    return session->sendQuery(p, &messagesForwardMessageMethods, attachedData, "Messages->forwardMessage" );
}

void TelegramApi::onMessagesForwardMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::forwardMessageResult(&inboundPkt);
    if(result.error())
        onMessagesForwardMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesForwardMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesForwardMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesForwardMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetDhConfig(qint32 version, qint32 random_length, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getDhConfig(&p, version, random_length);
    return session->sendQuery(p, &messagesGetDhConfigMethods, attachedData, "Messages->getDhConfig" );
}

void TelegramApi::onMessagesGetDhConfigAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesDhConfig &result = Functions::Messages::getDhConfigResult(&inboundPkt);
    if(result.error())
        onMessagesGetDhConfigError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetDhConfigAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetDhConfigError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetDhConfigError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesRequestEncryption(const InputUser &user_id, qint32 random_id, const QByteArray &g_a, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::requestEncryption(&p, user_id, random_id, g_a);
    return session->sendQuery(p, &messagesRequestEncryptionMethods, attachedData, "Messages->requestEncryption" );
}

void TelegramApi::onMessagesRequestEncryptionAnswer(Query *q, InboundPkt &inboundPkt) {
    const EncryptedChat &result = Functions::Messages::requestEncryptionResult(&inboundPkt);
    if(result.error())
        onMessagesRequestEncryptionError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesRequestEncryptionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesRequestEncryptionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesRequestEncryptionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesAcceptEncryption(const InputEncryptedChat &peer, const QByteArray &g_b, qint64 key_fingerprint, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::acceptEncryption(&p, peer, g_b, key_fingerprint);
    return session->sendQuery(p, &messagesAcceptEncryptionMethods, attachedData, "Messages->acceptEncryption" );
}

void TelegramApi::onMessagesAcceptEncryptionAnswer(Query *q, InboundPkt &inboundPkt) {
    const EncryptedChat &result = Functions::Messages::acceptEncryptionResult(&inboundPkt);
    if(result.error())
        onMessagesAcceptEncryptionError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesAcceptEncryptionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesAcceptEncryptionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesAcceptEncryptionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDiscardEncryption(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::discardEncryption(&p, chat_id);
    return session->sendQuery(p, &messagesDiscardEncryptionMethods, attachedData, "Messages->discardEncryption" );
}

void TelegramApi::onMessagesDiscardEncryptionAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::discardEncryptionResult(&inboundPkt);
    Q_EMIT messagesDiscardEncryptionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDiscardEncryptionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDiscardEncryptionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetEncryptedTyping(const InputEncryptedChat &peer, bool typing, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setEncryptedTyping(&p, peer, typing);
    return session->sendQuery(p, &messagesSetEncryptedTypingMethods, attachedData, "Messages->setEncryptedTyping" );
}

void TelegramApi::onMessagesSetEncryptedTypingAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setEncryptedTypingResult(&inboundPkt);
    Q_EMIT messagesSetEncryptedTypingAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetEncryptedTypingError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetEncryptedTypingError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadEncryptedHistory(const InputEncryptedChat &peer, qint32 max_date, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readEncryptedHistory(&p, peer, max_date);
    return session->sendQuery(p, &messagesReadEncryptedHistoryMethods, attachedData, "Messages->readEncryptedHistory" );
}

void TelegramApi::onMessagesReadEncryptedHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::readEncryptedHistoryResult(&inboundPkt);
    Q_EMIT messagesReadEncryptedHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadEncryptedHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadEncryptedHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendEncrypted(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendEncrypted(&p, peer, random_id, data);
    return session->sendQuery(p, &messagesSendEncryptedMethods, attachedData, "Messages->sendEncrypted" );
}

void TelegramApi::onMessagesSendEncryptedAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSentEncryptedMessage &result = Functions::Messages::sendEncryptedResult(&inboundPkt);
    if(result.error())
        onMessagesSendEncryptedError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendEncryptedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendEncryptedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendEncryptedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendEncryptedFile(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const InputEncryptedFile &file, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendEncryptedFile(&p, peer, random_id, data, file);
    return session->sendQuery(p, &messagesSendEncryptedFileMethods, attachedData, "Messages->sendEncryptedFile" );
}

void TelegramApi::onMessagesSendEncryptedFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSentEncryptedMessage &result = Functions::Messages::sendEncryptedFileResult(&inboundPkt);
    if(result.error())
        onMessagesSendEncryptedFileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendEncryptedFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendEncryptedFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendEncryptedFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendEncryptedService(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendEncryptedService(&p, peer, random_id, data);
    return session->sendQuery(p, &messagesSendEncryptedServiceMethods, attachedData, "Messages->sendEncryptedService" );
}

void TelegramApi::onMessagesSendEncryptedServiceAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSentEncryptedMessage &result = Functions::Messages::sendEncryptedServiceResult(&inboundPkt);
    if(result.error())
        onMessagesSendEncryptedServiceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendEncryptedServiceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendEncryptedServiceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendEncryptedServiceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReceivedQueue(qint32 max_qts, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::receivedQueue(&p, max_qts);
    return session->sendQuery(p, &messagesReceivedQueueMethods, attachedData, "Messages->receivedQueue" );
}

void TelegramApi::onMessagesReceivedQueueAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint64> &result = Functions::Messages::receivedQueueResult(&inboundPkt);
    Q_EMIT messagesReceivedQueueAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReceivedQueueError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReceivedQueueError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReportEncryptedSpam(const InputEncryptedChat &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::reportEncryptedSpam(&p, peer);
    return session->sendQuery(p, &messagesReportEncryptedSpamMethods, attachedData, "Messages->reportEncryptedSpam" );
}

void TelegramApi::onMessagesReportEncryptedSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::reportEncryptedSpamResult(&inboundPkt);
    Q_EMIT messagesReportEncryptedSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReportEncryptedSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReportEncryptedSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadMessageContents(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readMessageContents(&p, id);
    return session->sendQuery(p, &messagesReadMessageContentsMethods, attachedData, "Messages->readMessageContents" );
}

void TelegramApi::onMessagesReadMessageContentsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Messages::readMessageContentsResult(&inboundPkt);
    if(result.error())
        onMessagesReadMessageContentsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesReadMessageContentsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadMessageContentsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadMessageContentsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetAllStickers(qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getAllStickers(&p, hash);
    return session->sendQuery(p, &messagesGetAllStickersMethods, attachedData, "Messages->getAllStickers" );
}

void TelegramApi::onMessagesGetAllStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAllStickers &result = Functions::Messages::getAllStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetAllStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetAllStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetAllStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetAllStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetWebPagePreview(const QString &message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getWebPagePreview(&p, message);
    return session->sendQuery(p, &messagesGetWebPagePreviewMethods, attachedData, "Messages->getWebPagePreview" );
}

void TelegramApi::onMessagesGetWebPagePreviewAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessageMedia &result = Functions::Messages::getWebPagePreviewResult(&inboundPkt);
    if(result.error())
        onMessagesGetWebPagePreviewError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetWebPagePreviewAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetWebPagePreviewError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetWebPagePreviewError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesExportChatInvite(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::exportChatInvite(&p, chat_id);
    return session->sendQuery(p, &messagesExportChatInviteMethods, attachedData, "Messages->exportChatInvite" );
}

void TelegramApi::onMessagesExportChatInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const ExportedChatInvite &result = Functions::Messages::exportChatInviteResult(&inboundPkt);
    if(result.error())
        onMessagesExportChatInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesExportChatInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesExportChatInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesExportChatInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesCheckChatInvite(const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::checkChatInvite(&p, hash);
    return session->sendQuery(p, &messagesCheckChatInviteMethods, attachedData, "Messages->checkChatInvite" );
}

void TelegramApi::onMessagesCheckChatInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChatInvite &result = Functions::Messages::checkChatInviteResult(&inboundPkt);
    if(result.error())
        onMessagesCheckChatInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesCheckChatInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesCheckChatInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesCheckChatInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesImportChatInvite(const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::importChatInvite(&p, hash);
    return session->sendQuery(p, &messagesImportChatInviteMethods, attachedData, "Messages->importChatInvite" );
}

void TelegramApi::onMessagesImportChatInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::importChatInviteResult(&inboundPkt);
    if(result.error())
        onMessagesImportChatInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesImportChatInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesImportChatInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesImportChatInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetStickerSet(const InputStickerSet &stickerset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getStickerSet(&p, stickerset);
    return session->sendQuery(p, &messagesGetStickerSetMethods, attachedData, "Messages->getStickerSet" );
}

void TelegramApi::onMessagesGetStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesStickerSet &result = Functions::Messages::getStickerSetResult(&inboundPkt);
    if(result.error())
        onMessagesGetStickerSetError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesInstallStickerSet(const InputStickerSet &stickerset, bool archived, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::installStickerSet(&p, stickerset, archived);
    return session->sendQuery(p, &messagesInstallStickerSetMethods, attachedData, "Messages->installStickerSet" );
}

void TelegramApi::onMessagesInstallStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesStickerSetInstallResult &result = Functions::Messages::installStickerSetResult(&inboundPkt);
    if(result.error())
        onMessagesInstallStickerSetError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesInstallStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesInstallStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesInstallStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesUninstallStickerSet(const InputStickerSet &stickerset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::uninstallStickerSet(&p, stickerset);
    return session->sendQuery(p, &messagesUninstallStickerSetMethods, attachedData, "Messages->uninstallStickerSet" );
}

void TelegramApi::onMessagesUninstallStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::uninstallStickerSetResult(&inboundPkt);
    Q_EMIT messagesUninstallStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesUninstallStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesUninstallStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesStartBot(const InputUser &bot, const InputPeer &peer, qint64 random_id, const QString &start_param, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::startBot(&p, bot, peer, random_id, start_param);
    return session->sendQuery(p, &messagesStartBotMethods, attachedData, "Messages->startBot" );
}

void TelegramApi::onMessagesStartBotAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::startBotResult(&inboundPkt);
    if(result.error())
        onMessagesStartBotError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesStartBotAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesStartBotError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesStartBotError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetMessagesViews(const InputPeer &peer, const QList<qint32> &id, bool increment, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getMessagesViews(&p, peer, id, increment);
    return session->sendQuery(p, &messagesGetMessagesViewsMethods, attachedData, "Messages->getMessagesViews" );
}

void TelegramApi::onMessagesGetMessagesViewsAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint32> &result = Functions::Messages::getMessagesViewsResult(&inboundPkt);
    Q_EMIT messagesGetMessagesViewsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetMessagesViewsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetMessagesViewsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesToggleChatAdmins(qint32 chat_id, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::toggleChatAdmins(&p, chat_id, enabled);
    return session->sendQuery(p, &messagesToggleChatAdminsMethods, attachedData, "Messages->toggleChatAdmins" );
}

void TelegramApi::onMessagesToggleChatAdminsAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::toggleChatAdminsResult(&inboundPkt);
    if(result.error())
        onMessagesToggleChatAdminsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesToggleChatAdminsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesToggleChatAdminsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesToggleChatAdminsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditChatAdmin(qint32 chat_id, const InputUser &user_id, bool is_admin, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editChatAdmin(&p, chat_id, user_id, is_admin);
    return session->sendQuery(p, &messagesEditChatAdminMethods, attachedData, "Messages->editChatAdmin" );
}

void TelegramApi::onMessagesEditChatAdminAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::editChatAdminResult(&inboundPkt);
    Q_EMIT messagesEditChatAdminAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditChatAdminError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditChatAdminError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesMigrateChat(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::migrateChat(&p, chat_id);
    return session->sendQuery(p, &messagesMigrateChatMethods, attachedData, "Messages->migrateChat" );
}

void TelegramApi::onMessagesMigrateChatAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::migrateChatResult(&inboundPkt);
    if(result.error())
        onMessagesMigrateChatError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesMigrateChatAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesMigrateChatError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesMigrateChatError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSearchGlobal(const QString &q, qint32 offset_date, const InputPeer &offset_peer, qint32 offset_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::searchGlobal(&p, q, offset_date, offset_peer, offset_id, limit);
    return session->sendQuery(p, &messagesSearchGlobalMethods, attachedData, "Messages->searchGlobal" );
}

void TelegramApi::onMessagesSearchGlobalAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::searchGlobalResult(&inboundPkt);
    if(result.error())
        onMessagesSearchGlobalError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSearchGlobalAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSearchGlobalError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSearchGlobalError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReorderStickerSets(bool masks, const QList<qint64> &order, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::reorderStickerSets(&p, masks, order);
    return session->sendQuery(p, &messagesReorderStickerSetsMethods, attachedData, "Messages->reorderStickerSets" );
}

void TelegramApi::onMessagesReorderStickerSetsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::reorderStickerSetsResult(&inboundPkt);
    Q_EMIT messagesReorderStickerSetsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReorderStickerSetsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReorderStickerSetsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetDocumentByHash(const QByteArray &sha256, qint32 size, const QString &mime_type, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getDocumentByHash(&p, sha256, size, mime_type);
    return session->sendQuery(p, &messagesGetDocumentByHashMethods, attachedData, "Messages->getDocumentByHash" );
}

void TelegramApi::onMessagesGetDocumentByHashAnswer(Query *q, InboundPkt &inboundPkt) {
    const Document &result = Functions::Messages::getDocumentByHashResult(&inboundPkt);
    if(result.error())
        onMessagesGetDocumentByHashError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetDocumentByHashAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetDocumentByHashError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetDocumentByHashError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSearchGifs(const QString &q, qint32 offset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::searchGifs(&p, q, offset);
    return session->sendQuery(p, &messagesSearchGifsMethods, attachedData, "Messages->searchGifs" );
}

void TelegramApi::onMessagesSearchGifsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesFoundGifs &result = Functions::Messages::searchGifsResult(&inboundPkt);
    if(result.error())
        onMessagesSearchGifsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSearchGifsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSearchGifsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSearchGifsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetSavedGifs(qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getSavedGifs(&p, hash);
    return session->sendQuery(p, &messagesGetSavedGifsMethods, attachedData, "Messages->getSavedGifs" );
}

void TelegramApi::onMessagesGetSavedGifsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSavedGifs &result = Functions::Messages::getSavedGifsResult(&inboundPkt);
    if(result.error())
        onMessagesGetSavedGifsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetSavedGifsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetSavedGifsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetSavedGifsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSaveGif(const InputDocument &id, bool unsave, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::saveGif(&p, id, unsave);
    return session->sendQuery(p, &messagesSaveGifMethods, attachedData, "Messages->saveGif" );
}

void TelegramApi::onMessagesSaveGifAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::saveGifResult(&inboundPkt);
    Q_EMIT messagesSaveGifAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSaveGifError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSaveGifError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetInlineBotResults(const InputUser &bot, const InputPeer &peer, const InputGeoPoint &geo_point, const QString &query, const QString &offset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getInlineBotResults(&p, bot, peer, geo_point, query, offset);
    return session->sendQuery(p, &messagesGetInlineBotResultsMethods, attachedData, "Messages->getInlineBotResults" );
}

void TelegramApi::onMessagesGetInlineBotResultsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesBotResults &result = Functions::Messages::getInlineBotResultsResult(&inboundPkt);
    if(result.error())
        onMessagesGetInlineBotResultsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetInlineBotResultsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetInlineBotResultsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetInlineBotResultsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetInlineBotResults(bool gallery, bool privateValue, qint64 query_id, const QList<InputBotInlineResult> &results, qint32 cache_time, const QString &next_offset, const InlineBotSwitchPM &switch_pm, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setInlineBotResults(&p, gallery, privateValue, query_id, results, cache_time, next_offset, switch_pm);
    return session->sendQuery(p, &messagesSetInlineBotResultsMethods, attachedData, "Messages->setInlineBotResults" );
}

void TelegramApi::onMessagesSetInlineBotResultsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setInlineBotResultsResult(&inboundPkt);
    Q_EMIT messagesSetInlineBotResultsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetInlineBotResultsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetInlineBotResultsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendInlineBotResult(bool silent, bool background, bool clear_draft, const InputPeer &peer, qint32 reply_to_msg_id, qint64 random_id, qint64 query_id, const QString &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendInlineBotResult(&p, silent, background, clear_draft, peer, reply_to_msg_id, random_id, query_id, id);
    return session->sendQuery(p, &messagesSendInlineBotResultMethods, attachedData, "Messages->sendInlineBotResult" );
}

void TelegramApi::onMessagesSendInlineBotResultAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendInlineBotResultResult(&inboundPkt);
    if(result.error())
        onMessagesSendInlineBotResultError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendInlineBotResultAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendInlineBotResultError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendInlineBotResultError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetMessageEditData(const InputPeer &peer, qint32 id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getMessageEditData(&p, peer, id);
    return session->sendQuery(p, &messagesGetMessageEditDataMethods, attachedData, "Messages->getMessageEditData" );
}

void TelegramApi::onMessagesGetMessageEditDataAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessageEditData &result = Functions::Messages::getMessageEditDataResult(&inboundPkt);
    if(result.error())
        onMessagesGetMessageEditDataError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetMessageEditDataAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetMessageEditDataError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetMessageEditDataError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditMessage(bool no_webpage, const InputPeer &peer, qint32 id, const QString &message, const ReplyMarkup &reply_markup, const QList<MessageEntity> &entities, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editMessage(&p, no_webpage, peer, id, message, reply_markup, entities);
    return session->sendQuery(p, &messagesEditMessageMethods, attachedData, "Messages->editMessage" );
}

void TelegramApi::onMessagesEditMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::editMessageResult(&inboundPkt);
    if(result.error())
        onMessagesEditMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesEditMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditInlineBotMessage(bool no_webpage, const InputBotInlineMessageID &id, const QString &message, const ReplyMarkup &reply_markup, const QList<MessageEntity> &entities, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editInlineBotMessage(&p, no_webpage, id, message, reply_markup, entities);
    return session->sendQuery(p, &messagesEditInlineBotMessageMethods, attachedData, "Messages->editInlineBotMessage" );
}

void TelegramApi::onMessagesEditInlineBotMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::editInlineBotMessageResult(&inboundPkt);
    Q_EMIT messagesEditInlineBotMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditInlineBotMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditInlineBotMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetBotCallbackAnswer(bool game, const InputPeer &peer, qint32 msg_id, const QByteArray &data, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getBotCallbackAnswer(&p, game, peer, msg_id, data);
    return session->sendQuery(p, &messagesGetBotCallbackAnswerMethods, attachedData, "Messages->getBotCallbackAnswer" );
}

void TelegramApi::onMessagesGetBotCallbackAnswerAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesBotCallbackAnswer &result = Functions::Messages::getBotCallbackAnswerResult(&inboundPkt);
    if(result.error())
        onMessagesGetBotCallbackAnswerError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetBotCallbackAnswerAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetBotCallbackAnswerError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetBotCallbackAnswerError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetBotCallbackAnswer(bool alert, qint64 query_id, const QString &message, const QString &url, qint32 cache_time, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setBotCallbackAnswer(&p, alert, query_id, message, url, cache_time);
    return session->sendQuery(p, &messagesSetBotCallbackAnswerMethods, attachedData, "Messages->setBotCallbackAnswer" );
}

void TelegramApi::onMessagesSetBotCallbackAnswerAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setBotCallbackAnswerResult(&inboundPkt);
    Q_EMIT messagesSetBotCallbackAnswerAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetBotCallbackAnswerError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetBotCallbackAnswerError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetPeerDialogs(const QList<InputPeer> &peers, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getPeerDialogs(&p, peers);
    return session->sendQuery(p, &messagesGetPeerDialogsMethods, attachedData, "Messages->getPeerDialogs" );
}

void TelegramApi::onMessagesGetPeerDialogsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesPeerDialogs &result = Functions::Messages::getPeerDialogsResult(&inboundPkt);
    if(result.error())
        onMessagesGetPeerDialogsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetPeerDialogsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetPeerDialogsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetPeerDialogsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSaveDraft(bool no_webpage, qint32 reply_to_msg_id, const InputPeer &peer, const QString &message, const QList<MessageEntity> &entities, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::saveDraft(&p, no_webpage, reply_to_msg_id, peer, message, entities);
    return session->sendQuery(p, &messagesSaveDraftMethods, attachedData, "Messages->saveDraft" );
}

void TelegramApi::onMessagesSaveDraftAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::saveDraftResult(&inboundPkt);
    Q_EMIT messagesSaveDraftAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSaveDraftError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSaveDraftError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetAllDrafts(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getAllDrafts(&p);
    return session->sendQuery(p, &messagesGetAllDraftsMethods, attachedData, "Messages->getAllDrafts" );
}

void TelegramApi::onMessagesGetAllDraftsAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::getAllDraftsResult(&inboundPkt);
    if(result.error())
        onMessagesGetAllDraftsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetAllDraftsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetAllDraftsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetAllDraftsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetFeaturedStickers(qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getFeaturedStickers(&p, hash);
    return session->sendQuery(p, &messagesGetFeaturedStickersMethods, attachedData, "Messages->getFeaturedStickers" );
}

void TelegramApi::onMessagesGetFeaturedStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesFeaturedStickers &result = Functions::Messages::getFeaturedStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetFeaturedStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetFeaturedStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetFeaturedStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetFeaturedStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadFeaturedStickers(const QList<qint64> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readFeaturedStickers(&p, id);
    return session->sendQuery(p, &messagesReadFeaturedStickersMethods, attachedData, "Messages->readFeaturedStickers" );
}

void TelegramApi::onMessagesReadFeaturedStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::readFeaturedStickersResult(&inboundPkt);
    Q_EMIT messagesReadFeaturedStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadFeaturedStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadFeaturedStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetRecentStickers(bool attached, qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getRecentStickers(&p, attached, hash);
    return session->sendQuery(p, &messagesGetRecentStickersMethods, attachedData, "Messages->getRecentStickers" );
}

void TelegramApi::onMessagesGetRecentStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesRecentStickers &result = Functions::Messages::getRecentStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetRecentStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetRecentStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetRecentStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetRecentStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSaveRecentSticker(bool attached, const InputDocument &id, bool unsave, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::saveRecentSticker(&p, attached, id, unsave);
    return session->sendQuery(p, &messagesSaveRecentStickerMethods, attachedData, "Messages->saveRecentSticker" );
}

void TelegramApi::onMessagesSaveRecentStickerAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::saveRecentStickerResult(&inboundPkt);
    Q_EMIT messagesSaveRecentStickerAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSaveRecentStickerError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSaveRecentStickerError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesClearRecentStickers(bool attached, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::clearRecentStickers(&p, attached);
    return session->sendQuery(p, &messagesClearRecentStickersMethods, attachedData, "Messages->clearRecentStickers" );
}

void TelegramApi::onMessagesClearRecentStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::clearRecentStickersResult(&inboundPkt);
    Q_EMIT messagesClearRecentStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesClearRecentStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesClearRecentStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetArchivedStickers(bool masks, qint64 offset_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getArchivedStickers(&p, masks, offset_id, limit);
    return session->sendQuery(p, &messagesGetArchivedStickersMethods, attachedData, "Messages->getArchivedStickers" );
}

void TelegramApi::onMessagesGetArchivedStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesArchivedStickers &result = Functions::Messages::getArchivedStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetArchivedStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetArchivedStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetArchivedStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetArchivedStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetMaskStickers(qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getMaskStickers(&p, hash);
    return session->sendQuery(p, &messagesGetMaskStickersMethods, attachedData, "Messages->getMaskStickers" );
}

void TelegramApi::onMessagesGetMaskStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAllStickers &result = Functions::Messages::getMaskStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetMaskStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetMaskStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetMaskStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetMaskStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetAttachedStickers(const InputStickeredMedia &media, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getAttachedStickers(&p, media);
    return session->sendQuery(p, &messagesGetAttachedStickersMethods, attachedData, "Messages->getAttachedStickers" );
}

void TelegramApi::onMessagesGetAttachedStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<StickerSetCovered> &result = Functions::Messages::getAttachedStickersResult(&inboundPkt);
    Q_EMIT messagesGetAttachedStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetAttachedStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetAttachedStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetGameScore(bool edit_message, bool force, const InputPeer &peer, qint32 id, const InputUser &user_id, qint32 score, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setGameScore(&p, edit_message, force, peer, id, user_id, score);
    return session->sendQuery(p, &messagesSetGameScoreMethods, attachedData, "Messages->setGameScore" );
}

void TelegramApi::onMessagesSetGameScoreAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::setGameScoreResult(&inboundPkt);
    if(result.error())
        onMessagesSetGameScoreError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSetGameScoreAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetGameScoreError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetGameScoreError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetInlineGameScore(bool edit_message, bool force, const InputBotInlineMessageID &id, const InputUser &user_id, qint32 score, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setInlineGameScore(&p, edit_message, force, id, user_id, score);
    return session->sendQuery(p, &messagesSetInlineGameScoreMethods, attachedData, "Messages->setInlineGameScore" );
}

void TelegramApi::onMessagesSetInlineGameScoreAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setInlineGameScoreResult(&inboundPkt);
    Q_EMIT messagesSetInlineGameScoreAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetInlineGameScoreError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetInlineGameScoreError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetGameHighScores(const InputPeer &peer, qint32 id, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getGameHighScores(&p, peer, id, user_id);
    return session->sendQuery(p, &messagesGetGameHighScoresMethods, attachedData, "Messages->getGameHighScores" );
}

void TelegramApi::onMessagesGetGameHighScoresAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesHighScores &result = Functions::Messages::getGameHighScoresResult(&inboundPkt);
    if(result.error())
        onMessagesGetGameHighScoresError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetGameHighScoresAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetGameHighScoresError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetGameHighScoresError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetInlineGameHighScores(const InputBotInlineMessageID &id, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getInlineGameHighScores(&p, id, user_id);
    return session->sendQuery(p, &messagesGetInlineGameHighScoresMethods, attachedData, "Messages->getInlineGameHighScores" );
}

void TelegramApi::onMessagesGetInlineGameHighScoresAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesHighScores &result = Functions::Messages::getInlineGameHighScoresResult(&inboundPkt);
    if(result.error())
        onMessagesGetInlineGameHighScoresError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetInlineGameHighScoresAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetInlineGameHighScoresError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetInlineGameHighScoresError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetCommonChats(const InputUser &user_id, qint32 max_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getCommonChats(&p, user_id, max_id, limit);
    return session->sendQuery(p, &messagesGetCommonChatsMethods, attachedData, "Messages->getCommonChats" );
}

void TelegramApi::onMessagesGetCommonChatsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Messages::getCommonChatsResult(&inboundPkt);
    if(result.error())
        onMessagesGetCommonChatsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetCommonChatsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetCommonChatsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetCommonChatsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetAllChats(const QList<qint32> &except_ids, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getAllChats(&p, except_ids);
    return session->sendQuery(p, &messagesGetAllChatsMethods, attachedData, "Messages->getAllChats" );
}

void TelegramApi::onMessagesGetAllChatsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Messages::getAllChatsResult(&inboundPkt);
    if(result.error())
        onMessagesGetAllChatsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetAllChatsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetAllChatsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetAllChatsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetWebPage(const QString &url, qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getWebPage(&p, url, hash);
    return session->sendQuery(p, &messagesGetWebPageMethods, attachedData, "Messages->getWebPage" );
}

void TelegramApi::onMessagesGetWebPageAnswer(Query *q, InboundPkt &inboundPkt) {
    const WebPage &result = Functions::Messages::getWebPageResult(&inboundPkt);
    if(result.error())
        onMessagesGetWebPageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetWebPageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetWebPageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetWebPageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesToggleDialogPin(bool pinned, const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::toggleDialogPin(&p, pinned, peer);
    return session->sendQuery(p, &messagesToggleDialogPinMethods, attachedData, "Messages->toggleDialogPin" );
}

void TelegramApi::onMessagesToggleDialogPinAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::toggleDialogPinResult(&inboundPkt);
    Q_EMIT messagesToggleDialogPinAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesToggleDialogPinError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesToggleDialogPinError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReorderPinnedDialogs(bool force, const QList<InputPeer> &order, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::reorderPinnedDialogs(&p, force, order);
    return session->sendQuery(p, &messagesReorderPinnedDialogsMethods, attachedData, "Messages->reorderPinnedDialogs" );
}

void TelegramApi::onMessagesReorderPinnedDialogsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::reorderPinnedDialogsResult(&inboundPkt);
    Q_EMIT messagesReorderPinnedDialogsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReorderPinnedDialogsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReorderPinnedDialogsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetPinnedDialogs(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getPinnedDialogs(&p);
    return session->sendQuery(p, &messagesGetPinnedDialogsMethods, attachedData, "Messages->getPinnedDialogs" );
}

void TelegramApi::onMessagesGetPinnedDialogsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesPeerDialogs &result = Functions::Messages::getPinnedDialogsResult(&inboundPkt);
    if(result.error())
        onMessagesGetPinnedDialogsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetPinnedDialogsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetPinnedDialogsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetPinnedDialogsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetBotShippingResults(qint64 query_id, const QString &error, const QList<ShippingOption> &shipping_options, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setBotShippingResults(&p, query_id, error, shipping_options);
    return session->sendQuery(p, &messagesSetBotShippingResultsMethods, attachedData, "Messages->setBotShippingResults" );
}

void TelegramApi::onMessagesSetBotShippingResultsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setBotShippingResultsResult(&inboundPkt);
    Q_EMIT messagesSetBotShippingResultsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetBotShippingResultsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetBotShippingResultsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetBotPrecheckoutResults(bool success, qint64 query_id, const QString &error, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setBotPrecheckoutResults(&p, success, query_id, error);
    return session->sendQuery(p, &messagesSetBotPrecheckoutResultsMethods, attachedData, "Messages->setBotPrecheckoutResults" );
}

void TelegramApi::onMessagesSetBotPrecheckoutResultsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setBotPrecheckoutResultsResult(&inboundPkt);
    Q_EMIT messagesSetBotPrecheckoutResultsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetBotPrecheckoutResultsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetBotPrecheckoutResultsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesUploadMedia(const InputPeer &peer, const InputMedia &media, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::uploadMedia(&p, peer, media);
    return session->sendQuery(p, &messagesUploadMediaMethods, attachedData, "Messages->uploadMedia" );
}

void TelegramApi::onMessagesUploadMediaAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessageMedia &result = Functions::Messages::uploadMediaResult(&inboundPkt);
    if(result.error())
        onMessagesUploadMediaError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesUploadMediaAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesUploadMediaError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesUploadMediaError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::paymentsGetPaymentForm(qint32 msg_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Payments::getPaymentForm(&p, msg_id);
    return session->sendQuery(p, &paymentsGetPaymentFormMethods, attachedData, "Payments->getPaymentForm" );
}

void TelegramApi::onPaymentsGetPaymentFormAnswer(Query *q, InboundPkt &inboundPkt) {
    const PaymentsPaymentForm &result = Functions::Payments::getPaymentFormResult(&inboundPkt);
    if(result.error())
        onPaymentsGetPaymentFormError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT paymentsGetPaymentFormAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPaymentsGetPaymentFormError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT paymentsGetPaymentFormError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::paymentsGetPaymentReceipt(qint32 msg_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Payments::getPaymentReceipt(&p, msg_id);
    return session->sendQuery(p, &paymentsGetPaymentReceiptMethods, attachedData, "Payments->getPaymentReceipt" );
}

void TelegramApi::onPaymentsGetPaymentReceiptAnswer(Query *q, InboundPkt &inboundPkt) {
    const PaymentsPaymentReceipt &result = Functions::Payments::getPaymentReceiptResult(&inboundPkt);
    if(result.error())
        onPaymentsGetPaymentReceiptError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT paymentsGetPaymentReceiptAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPaymentsGetPaymentReceiptError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT paymentsGetPaymentReceiptError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::paymentsValidateRequestedInfo(bool save, qint32 msg_id, const PaymentRequestedInfo &info, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Payments::validateRequestedInfo(&p, save, msg_id, info);
    return session->sendQuery(p, &paymentsValidateRequestedInfoMethods, attachedData, "Payments->validateRequestedInfo" );
}

void TelegramApi::onPaymentsValidateRequestedInfoAnswer(Query *q, InboundPkt &inboundPkt) {
    const PaymentsValidatedRequestedInfo &result = Functions::Payments::validateRequestedInfoResult(&inboundPkt);
    if(result.error())
        onPaymentsValidateRequestedInfoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT paymentsValidateRequestedInfoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPaymentsValidateRequestedInfoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT paymentsValidateRequestedInfoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::paymentsSendPaymentForm(qint32 msg_id, const QString &requested_info_id, const QString &shipping_option_id, const InputPaymentCredentials &credentials, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Payments::sendPaymentForm(&p, msg_id, requested_info_id, shipping_option_id, credentials);
    return session->sendQuery(p, &paymentsSendPaymentFormMethods, attachedData, "Payments->sendPaymentForm" );
}

void TelegramApi::onPaymentsSendPaymentFormAnswer(Query *q, InboundPkt &inboundPkt) {
    const PaymentsPaymentResult &result = Functions::Payments::sendPaymentFormResult(&inboundPkt);
    if(result.error())
        onPaymentsSendPaymentFormError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT paymentsSendPaymentFormAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPaymentsSendPaymentFormError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT paymentsSendPaymentFormError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::paymentsGetSavedInfo(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Payments::getSavedInfo(&p);
    return session->sendQuery(p, &paymentsGetSavedInfoMethods, attachedData, "Payments->getSavedInfo" );
}

void TelegramApi::onPaymentsGetSavedInfoAnswer(Query *q, InboundPkt &inboundPkt) {
    const PaymentsSavedInfo &result = Functions::Payments::getSavedInfoResult(&inboundPkt);
    if(result.error())
        onPaymentsGetSavedInfoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT paymentsGetSavedInfoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPaymentsGetSavedInfoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT paymentsGetSavedInfoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::paymentsClearSavedInfo(bool credentials, bool info, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Payments::clearSavedInfo(&p, credentials, info);
    return session->sendQuery(p, &paymentsClearSavedInfoMethods, attachedData, "Payments->clearSavedInfo" );
}

void TelegramApi::onPaymentsClearSavedInfoAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Payments::clearSavedInfoResult(&inboundPkt);
    Q_EMIT paymentsClearSavedInfoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPaymentsClearSavedInfoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT paymentsClearSavedInfoError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::phoneGetCallConfig(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::getCallConfig(&p);
    return session->sendQuery(p, &phoneGetCallConfigMethods, attachedData, "Phone->getCallConfig" );
}

void TelegramApi::onPhoneGetCallConfigAnswer(Query *q, InboundPkt &inboundPkt) {
    const DataJSON &result = Functions::Phone::getCallConfigResult(&inboundPkt);
    if(result.error())
        onPhoneGetCallConfigError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT phoneGetCallConfigAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneGetCallConfigError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneGetCallConfigError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneRequestCall(const InputUser &user_id, qint32 random_id, const QByteArray &g_a_hash, const PhoneCallProtocol &protocol, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::requestCall(&p, user_id, random_id, g_a_hash, protocol);
    return session->sendQuery(p, &phoneRequestCallMethods, attachedData, "Phone->requestCall" );
}

void TelegramApi::onPhoneRequestCallAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhonePhoneCall &result = Functions::Phone::requestCallResult(&inboundPkt);
    if(result.error())
        onPhoneRequestCallError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT phoneRequestCallAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneRequestCallError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneRequestCallError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneAcceptCall(const InputPhoneCall &peer, const QByteArray &g_b, const PhoneCallProtocol &protocol, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::acceptCall(&p, peer, g_b, protocol);
    return session->sendQuery(p, &phoneAcceptCallMethods, attachedData, "Phone->acceptCall" );
}

void TelegramApi::onPhoneAcceptCallAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhonePhoneCall &result = Functions::Phone::acceptCallResult(&inboundPkt);
    if(result.error())
        onPhoneAcceptCallError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT phoneAcceptCallAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneAcceptCallError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneAcceptCallError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneConfirmCall(const InputPhoneCall &peer, const QByteArray &g_a, qint64 key_fingerprint, const PhoneCallProtocol &protocol, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::confirmCall(&p, peer, g_a, key_fingerprint, protocol);
    return session->sendQuery(p, &phoneConfirmCallMethods, attachedData, "Phone->confirmCall" );
}

void TelegramApi::onPhoneConfirmCallAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhonePhoneCall &result = Functions::Phone::confirmCallResult(&inboundPkt);
    if(result.error())
        onPhoneConfirmCallError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT phoneConfirmCallAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneConfirmCallError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneConfirmCallError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneReceivedCall(const InputPhoneCall &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::receivedCall(&p, peer);
    return session->sendQuery(p, &phoneReceivedCallMethods, attachedData, "Phone->receivedCall" );
}

void TelegramApi::onPhoneReceivedCallAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Phone::receivedCallResult(&inboundPkt);
    Q_EMIT phoneReceivedCallAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneReceivedCallError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneReceivedCallError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneDiscardCall(const InputPhoneCall &peer, qint32 duration, const PhoneCallDiscardReason &reason, qint64 connection_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::discardCall(&p, peer, duration, reason, connection_id);
    return session->sendQuery(p, &phoneDiscardCallMethods, attachedData, "Phone->discardCall" );
}

void TelegramApi::onPhoneDiscardCallAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Phone::discardCallResult(&inboundPkt);
    if(result.error())
        onPhoneDiscardCallError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT phoneDiscardCallAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneDiscardCallError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneDiscardCallError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneSetCallRating(const InputPhoneCall &peer, qint32 rating, const QString &comment, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::setCallRating(&p, peer, rating, comment);
    return session->sendQuery(p, &phoneSetCallRatingMethods, attachedData, "Phone->setCallRating" );
}

void TelegramApi::onPhoneSetCallRatingAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Phone::setCallRatingResult(&inboundPkt);
    if(result.error())
        onPhoneSetCallRatingError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT phoneSetCallRatingAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneSetCallRatingError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneSetCallRatingError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::phoneSaveCallDebug(const InputPhoneCall &peer, const DataJSON &debug, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Phone::saveCallDebug(&p, peer, debug);
    return session->sendQuery(p, &phoneSaveCallDebugMethods, attachedData, "Phone->saveCallDebug" );
}

void TelegramApi::onPhoneSaveCallDebugAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Phone::saveCallDebugResult(&inboundPkt);
    Q_EMIT phoneSaveCallDebugAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhoneSaveCallDebugError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT phoneSaveCallDebugError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::photosUpdateProfilePhoto(const InputPhoto &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::updateProfilePhoto(&p, id);
    return session->sendQuery(p, &photosUpdateProfilePhotoMethods, attachedData, "Photos->updateProfilePhoto" );
}

void TelegramApi::onPhotosUpdateProfilePhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const UserProfilePhoto &result = Functions::Photos::updateProfilePhotoResult(&inboundPkt);
    if(result.error())
        onPhotosUpdateProfilePhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT photosUpdateProfilePhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosUpdateProfilePhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosUpdateProfilePhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::photosUploadProfilePhoto(const InputFile &file, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::uploadProfilePhoto(&p, file);
    return session->sendQuery(p, &photosUploadProfilePhotoMethods, attachedData, "Photos->uploadProfilePhoto" );
}

void TelegramApi::onPhotosUploadProfilePhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhotosPhoto &result = Functions::Photos::uploadProfilePhotoResult(&inboundPkt);
    if(result.error())
        onPhotosUploadProfilePhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT photosUploadProfilePhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosUploadProfilePhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosUploadProfilePhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::photosDeletePhotos(const QList<InputPhoto> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::deletePhotos(&p, id);
    return session->sendQuery(p, &photosDeletePhotosMethods, attachedData, "Photos->deletePhotos" );
}

void TelegramApi::onPhotosDeletePhotosAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint64> &result = Functions::Photos::deletePhotosResult(&inboundPkt);
    Q_EMIT photosDeletePhotosAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosDeletePhotosError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosDeletePhotosError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::photosGetUserPhotos(const InputUser &user_id, qint32 offset, qint64 max_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::getUserPhotos(&p, user_id, offset, max_id, limit);
    return session->sendQuery(p, &photosGetUserPhotosMethods, attachedData, "Photos->getUserPhotos" );
}

void TelegramApi::onPhotosGetUserPhotosAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhotosPhotos &result = Functions::Photos::getUserPhotosResult(&inboundPkt);
    if(result.error())
        onPhotosGetUserPhotosError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT photosGetUserPhotosAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosGetUserPhotosError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosGetUserPhotosError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::stickersCreateStickerSet(bool masks, const InputUser &user_id, const QString &title, const QString &short_name, const QList<InputStickerSetItem> &stickers, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Stickers::createStickerSet(&p, masks, user_id, title, short_name, stickers);
    return session->sendQuery(p, &stickersCreateStickerSetMethods, attachedData, "Stickers->createStickerSet" );
}

void TelegramApi::onStickersCreateStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesStickerSet &result = Functions::Stickers::createStickerSetResult(&inboundPkt);
    if(result.error())
        onStickersCreateStickerSetError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT stickersCreateStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onStickersCreateStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT stickersCreateStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::stickersRemoveStickerFromSet(const InputDocument &sticker, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Stickers::removeStickerFromSet(&p, sticker);
    return session->sendQuery(p, &stickersRemoveStickerFromSetMethods, attachedData, "Stickers->removeStickerFromSet" );
}

void TelegramApi::onStickersRemoveStickerFromSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Stickers::removeStickerFromSetResult(&inboundPkt);
    Q_EMIT stickersRemoveStickerFromSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onStickersRemoveStickerFromSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT stickersRemoveStickerFromSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::stickersChangeStickerPosition(const InputDocument &sticker, qint32 position, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Stickers::changeStickerPosition(&p, sticker, position);
    return session->sendQuery(p, &stickersChangeStickerPositionMethods, attachedData, "Stickers->changeStickerPosition" );
}

void TelegramApi::onStickersChangeStickerPositionAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Stickers::changeStickerPositionResult(&inboundPkt);
    Q_EMIT stickersChangeStickerPositionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onStickersChangeStickerPositionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT stickersChangeStickerPositionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::stickersAddStickerToSet(const InputStickerSet &stickerset, const InputStickerSetItem &sticker, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Stickers::addStickerToSet(&p, stickerset, sticker);
    return session->sendQuery(p, &stickersAddStickerToSetMethods, attachedData, "Stickers->addStickerToSet" );
}

void TelegramApi::onStickersAddStickerToSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesStickerSet &result = Functions::Stickers::addStickerToSetResult(&inboundPkt);
    if(result.error())
        onStickersAddStickerToSetError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT stickersAddStickerToSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onStickersAddStickerToSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT stickersAddStickerToSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::updatesGetState(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Updates::getState(&p);
    return session->sendQuery(p, &updatesGetStateMethods, attachedData, "Updates->getState" );
}

void TelegramApi::onUpdatesGetStateAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesState &result = Functions::Updates::getStateResult(&inboundPkt);
    if(result.error())
        onUpdatesGetStateError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT updatesGetStateAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUpdatesGetStateError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT updatesGetStateError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::updatesGetDifference(qint32 pts, qint32 pts_total_limit, qint32 date, qint32 qts, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Updates::getDifference(&p, pts, pts_total_limit, date, qts);
    return session->sendQuery(p, &updatesGetDifferenceMethods, attachedData, "Updates->getDifference" );
}

void TelegramApi::onUpdatesGetDifferenceAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesDifference &result = Functions::Updates::getDifferenceResult(&inboundPkt);
    if(result.error())
        onUpdatesGetDifferenceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT updatesGetDifferenceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUpdatesGetDifferenceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT updatesGetDifferenceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::updatesGetChannelDifference(bool force, const InputChannel &channel, const ChannelMessagesFilter &filter, qint32 pts, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Updates::getChannelDifference(&p, force, channel, filter, pts, limit);
    return session->sendQuery(p, &updatesGetChannelDifferenceMethods, attachedData, "Updates->getChannelDifference" );
}

void TelegramApi::onUpdatesGetChannelDifferenceAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesChannelDifference &result = Functions::Updates::getChannelDifferenceResult(&inboundPkt);
    if(result.error())
        onUpdatesGetChannelDifferenceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT updatesGetChannelDifferenceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUpdatesGetChannelDifferenceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT updatesGetChannelDifferenceError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::uploadSaveFilePart(qint64 file_id, qint32 file_part, const QByteArray &bytes, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::saveFilePart(&p, file_id, file_part, bytes);
    return session->sendQuery(p, &uploadSaveFilePartMethods, attachedData, "Upload->saveFilePart" );
}

void TelegramApi::onUploadSaveFilePartAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Upload::saveFilePartResult(&inboundPkt);
    Q_EMIT uploadSaveFilePartAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadSaveFilePartError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadSaveFilePartError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadGetFile(const InputFileLocation &location, qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::getFile(&p, location, offset, limit);
    return session->sendQuery(p, &uploadGetFileMethods, attachedData, "Upload->getFile" );
}

void TelegramApi::onUploadGetFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const UploadFile &result = Functions::Upload::getFileResult(&inboundPkt);
    if(result.error())
        onUploadGetFileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT uploadGetFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadGetFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadGetFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadSaveBigFilePart(qint64 file_id, qint32 file_part, qint32 file_total_parts, const QByteArray &bytes, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::saveBigFilePart(&p, file_id, file_part, file_total_parts, bytes);
    return session->sendQuery(p, &uploadSaveBigFilePartMethods, attachedData, "Upload->saveBigFilePart" );
}

void TelegramApi::onUploadSaveBigFilePartAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Upload::saveBigFilePartResult(&inboundPkt);
    Q_EMIT uploadSaveBigFilePartAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadSaveBigFilePartError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadSaveBigFilePartError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadGetWebFile(const InputWebFileLocation &location, qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::getWebFile(&p, location, offset, limit);
    return session->sendQuery(p, &uploadGetWebFileMethods, attachedData, "Upload->getWebFile" );
}

void TelegramApi::onUploadGetWebFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const UploadWebFile &result = Functions::Upload::getWebFileResult(&inboundPkt);
    if(result.error())
        onUploadGetWebFileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT uploadGetWebFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadGetWebFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadGetWebFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadGetCdnFile(const QByteArray &file_token, qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::getCdnFile(&p, file_token, offset, limit);
    return session->sendQuery(p, &uploadGetCdnFileMethods, attachedData, "Upload->getCdnFile" );
}

void TelegramApi::onUploadGetCdnFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const UploadCdnFile &result = Functions::Upload::getCdnFileResult(&inboundPkt);
    if(result.error())
        onUploadGetCdnFileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT uploadGetCdnFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadGetCdnFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadGetCdnFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadReuploadCdnFile(const QByteArray &file_token, const QByteArray &request_token, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::reuploadCdnFile(&p, file_token, request_token);
    return session->sendQuery(p, &uploadReuploadCdnFileMethods, attachedData, "Upload->reuploadCdnFile" );
}

void TelegramApi::onUploadReuploadCdnFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Upload::reuploadCdnFileResult(&inboundPkt);
    Q_EMIT uploadReuploadCdnFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadReuploadCdnFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadReuploadCdnFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::usersGetUsers(const QList<InputUser> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Users::getUsers(&p, id);
    return session->sendQuery(p, &usersGetUsersMethods, attachedData, "Users->getUsers" );
}

void TelegramApi::onUsersGetUsersAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<User> &result = Functions::Users::getUsersResult(&inboundPkt);
    Q_EMIT usersGetUsersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUsersGetUsersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT usersGetUsersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::usersGetFullUser(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    //DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Users::getFullUser(&p, id);
    return session->sendQuery(p, &usersGetFullUserMethods, attachedData, "Users->getFullUser" );
}

void TelegramApi::onUsersGetFullUserAnswer(Query *q, InboundPkt &inboundPkt) {
    const UserFull &result = Functions::Users::getFullUserResult(&inboundPkt);
    if(result.error())
        onUsersGetFullUserError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT usersGetFullUserAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUsersGetFullUserError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT usersGetFullUserError(q->mainMsgId(), errorCode, errorText, q->extra());
}

void TelegramApi::onError(Query *q, qint32 errorCode, const QString &errorText, const QVariant &attachedData, bool &accepted) {
    Q_EMIT error(q->msgId(), errorCode, errorText, q->name(), attachedData, accepted);
}
