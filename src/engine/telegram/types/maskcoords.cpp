// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "maskcoords.h"
#include "core/inboundpkt.h"
#include "core/outboundpkt.h"
#include "../coretypes.h"

#include <QDataStream>

MaskCoords::MaskCoords(MaskCoordsClassType classType, InboundPkt *in) :
    m_n(0),
    m_x(0),
    m_y(0),
    m_zoom(0),
    m_classType(classType)
{
    if(in) fetch(in);
}

MaskCoords::MaskCoords(InboundPkt *in) :
    m_n(0),
    m_x(0),
    m_y(0),
    m_zoom(0),
    m_classType(typeMaskCoords)
{
    fetch(in);
}

MaskCoords::MaskCoords(const MaskCoords &another) :
    TelegramTypeObject(),
    m_n(0),
    m_x(0),
    m_y(0),
    m_zoom(0),
    m_classType(typeMaskCoords)
{
    operator=(another);
}

MaskCoords::MaskCoords(const Null &null) :
    TelegramTypeObject(null),
    m_n(0),
    m_x(0),
    m_y(0),
    m_zoom(0),
    m_classType(typeMaskCoords)
{
}

MaskCoords::~MaskCoords() {

}

void MaskCoords::setN(qint32 n) {
    m_n = n;
}

qint32 MaskCoords::n() const {
    return m_n;
}

void MaskCoords::setX(qreal x) {
    m_x = x;
}

qreal MaskCoords::x() const {
    return m_x;
}

void MaskCoords::setY(qreal y) {
    m_y = y;
}

qreal MaskCoords::y() const {
    return m_y;
}

void MaskCoords::setZoom(qreal zoom) {
    m_zoom = zoom;
}

qreal MaskCoords::zoom() const {
    return m_zoom;
}

bool MaskCoords::operator ==(const MaskCoords &b) const {
    return m_classType == b.m_classType &&
           m_n == b.m_n &&
           m_x == b.m_x &&
           m_y == b.m_y &&
           m_zoom == b.m_zoom;
}

MaskCoords &MaskCoords::operator =(const MaskCoords &b) {
    m_classType = b.m_classType;
    m_n = b.m_n;
    m_x = b.m_x;
    m_y = b.m_y;
    m_zoom = b.m_zoom;
    setNull(b.isNull());
    return *this;
}

void MaskCoords::setClassType(MaskCoords::MaskCoordsClassType classType) {
    m_classType = classType;
}

MaskCoords::MaskCoordsClassType MaskCoords::classType() const {
    return m_classType;
}

bool MaskCoords::fetch(InboundPkt *in) {
    LQTG_FETCH_LOG;
    int x = in->fetchInt();
    switch(x) {
    case typeMaskCoords: {
        m_n = in->fetchInt();
        m_x = in->fetchDouble();
        m_y = in->fetchDouble();
        m_zoom = in->fetchDouble();
        m_classType = static_cast<MaskCoordsClassType>(x);
        return true;
    }
        break;

    default:
        LQTG_FETCH_ASSERT;
        return false;
    }
}

bool MaskCoords::push(OutboundPkt *out) const {
    out->appendInt(m_classType);
    switch(m_classType) {
    case typeMaskCoords: {
        out->appendInt(m_n);
        out->appendDouble(m_x);
        out->appendDouble(m_y);
        out->appendDouble(m_zoom);
        return true;
    }
        break;

    default:
        return false;
    }
}

QMap<QString, QVariant> MaskCoords::toMap() const {
    QMap<QString, QVariant> result;
    switch(static_cast<int>(m_classType)) {
    case typeMaskCoords: {
        result["classType"] = "MaskCoords::typeMaskCoords";
        if( n() ) result["n"] = QString::number(n());
        if( x() ) result["x"] = QString::number(x());
        if( y() ) result["y"] = QString::number(y());
        if( zoom() ) result["zoom"] = QString::number(zoom());
        return result;
    }
        break;

    default:
        return result;
    }
}

MaskCoords MaskCoords::fromMap(const QMap<QString, QVariant> &map) {
    MaskCoords result;
    if(map.value("classType").toString() == "MaskCoords::typeMaskCoords") {
        result.setClassType(typeMaskCoords);
        QVariant _n_var = map.value("n");
        if( !_n_var.isNull() ) {
            _n_var.convert( QVariant::nameToType("qint32") );
            result.setN( _n_var.value<qint32>() );
        }

        QVariant _x_var = map.value("x");
        if( !_x_var.isNull() ) {
            _x_var.convert( QVariant::nameToType("qreal") );
            result.setX( _x_var.value<qreal>() );
        }

        QVariant _y_var = map.value("y");
        if( !_y_var.isNull() ) {
            _y_var.convert( QVariant::nameToType("qreal") );
            result.setY( _y_var.value<qreal>() );
        }

        QVariant _zoom_var = map.value("zoom");
        if( !_zoom_var.isNull() ) {
            _zoom_var.convert( QVariant::nameToType("qreal") );
            result.setZoom( _zoom_var.value<qreal>() );
        }

        return result;
    }
    return result;
}

MaskCoords MaskCoords::fromJson(const QString &json) {
    return MaskCoords::fromMap(QJsonDocument::fromJson(json.toUtf8()).toVariant().toMap());
}

QByteArray MaskCoords::getHash(QCryptographicHash::Algorithm alg) const {
    QByteArray data;
    QDataStream str(&data, QIODevice::WriteOnly);
    str << *this;
    return QCryptographicHash::hash(data, alg);
}

QDataStream &operator<<(QDataStream &stream, const MaskCoords &item) {
    stream << static_cast<uint>(item.classType());
    switch(item.classType()) {
    case MaskCoords::typeMaskCoords:
        stream << item.n();
        stream << item.x();
        stream << item.y();
        stream << item.zoom();
        break;
    }
    return stream;
}

QDataStream &operator>>(QDataStream &stream, MaskCoords &item) {
    uint type = 0;
    stream >> type;
    item.setClassType(static_cast<MaskCoords::MaskCoordsClassType>(type));
    switch(type) {
    case MaskCoords::typeMaskCoords: {
        qint32 m_n;
        stream >> m_n;
        item.setN(m_n);
        qreal m_x;
        stream >> m_x;
        item.setX(m_x);
        qreal m_y;
        stream >> m_y;
        item.setY(m_y);
        qreal m_zoom;
        stream >> m_zoom;
        item.setZoom(m_zoom);
    }
        break;
    }
    return stream;
}

/*QDebug operator<<(QDebug debug,  const MaskCoords &item) {
    QDebugStateSaver saver(debug);
    Q_UNUSED(saver)
    debug.nospace() << "Telegram.MaskCoords(";
    switch(item.classType()) {
    case MaskCoords::typeMaskCoords:
        debug.nospace() << "classType: typeMaskCoords";
        debug.nospace() << ", n: " << item.n();
        debug.nospace() << ", x: " << item.x();
        debug.nospace() << ", y: " << item.y();
        debug.nospace() << ", zoom: " << item.zoom();
        break;
    }
    debug.nospace() << ")";
    return debug;
}
*/
